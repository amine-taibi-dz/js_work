{"version":3,"sources":["parsebone.js"],"names":["moduleExport","define","amd","module","exports","this","Parse","VERSION","createReduce","dir","iterator","obj","iteratee","memo","keys","index","length","currentKey","context","optimizeCb","isArrayLike","_","arguments","createPredicateIndexFinder","array","predicate","cb","getLength","createIndexFinder","predicateFind","sortedIndex","item","idx","i","Math","max","min","slice","call","isNaN","collectNonEnumProps","nonEnumIdx","nonEnumerableProps","constructor","proto","isFunction","prototype","ObjProto","prop","has","contains","push","root","previousUnderscore","ArrayProto","Array","Object","FuncProto","Function","toString","hasOwnProperty","nativeIsArray","isArray","nativeKeys","nativeBind","bind","nativeCreate","create","Ctor","_wrapped","func","argCount","value","other","collection","accumulator","apply","identity","isObject","matcher","property","Infinity","createAssigner","keysFunc","undefinedOnly","source","l","key","baseCreate","result","MAX_ARRAY_INDEX","pow","each","forEach","map","collect","results","reduce","foldl","inject","reduceRight","foldr","find","detect","findIndex","findKey","filter","select","list","reject","negate","every","all","some","any","includes","include","fromIndex","guard","values","indexOf","invoke","method","args","isFunc","pluck","where","attrs","findWhere","computed","lastComputed","shuffle","rand","set","shuffled","random","sample","n","sortBy","criteria","sort","left","right","a","b","group","behavior","groupBy","indexBy","countBy","toArray","size","partition","pass","fail","first","head","take","initial","last","rest","tail","drop","compact","flatten","input","shallow","strict","startIndex","output","isArguments","j","len","without","difference","uniq","unique","isSorted","isBoolean","seen","union","intersection","argsLength","zip","unzip","object","findLastIndex","low","high","mid","floor","lastIndexOf","range","start","stop","step","ceil","executeBound","sourceFunc","boundFunc","callingContext","self","TypeError","bound","concat","partial","boundArgs","position","bindAll","Error","memoize","hasher","cache","address","delay","wait","setTimeout","defer","throttle","options","timeout","previous","later","leading","now","remaining","clearTimeout","trailing","debounce","immediate","timestamp","callNow","wrap","wrapper","compose","after","times","before","once","hasEnumBug","propertyIsEnumerable","allKeys","mapObject","pairs","invert","functions","methods","names","extend","extendOwn","assign","pick","oiteratee","omit","String","defaults","props","clone","tap","interceptor","isMatch","eq","aStack","bStack","className","areArrays","aCtor","bCtor","pop","isEqual","isEmpty","isString","isElement","nodeType","type","name","Int8Array","isFinite","parseFloat","isNumber","isNull","isUndefined","noConflict","constant","noop","propertyOf","matches","accum","Date","getTime","escapeMap","&","<",">","\"","'","`","unescapeMap","createEscaper","escaper","match","join","testRegexp","RegExp","replaceRegexp","string","test","replace","escape","unescape","fallback","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","\\","\r","\n"," "," ","escapeChar","template","text","settings","oldSettings","offset","variable","render","e","data","argument","chain","instance","_chain","mixin","valueOf","toJSON","req","require","XMLHttpRequest","$","EmptyConstructor","inherits","parent","protoProps","staticProps","child","__super__","serverURL","process","versions","node","_isNode","initialize","applicationId","javaScriptKey","masterKey","_initialize","_useMasterKey","Cloud","useMasterKey","_getParsePath","path","substring","_installationId","_getInstallationId","Promise","as","Storage","getItemAsync","then","hexOctet","setItemAsync","_parseDate","iso8601","regexp","exec","year","month","day","hour","minute","second","milli","UTC","_ajaxIE8","url","promise","xdr","XDomainRequest","onload","response","JSON","parse","responseText","resolve","onerror","ontimeout","fakeResponse","stringify","code","X_DOMAIN_REQUEST","error","onprogress","open","send","_useXDomainRequest","_ajax","success","_thenRunCallbacks","attempts","dispatch","handled","xhr","onreadystatechange","readyState","status","round","setRequestHeader","_extend","classProps","_request","route","objectId","sessionToken","dataObject","charAt","_method","_ApplicationId","_MasterKey","_JavaScriptKey","_ClientVersion","iid","_InstallationId","_sessionToken","User","_canUseCurrentUser","_currentAsync","currentUser","_SessionToken","_isRevocableSessionEnabled","_RevocableSession","errorJSON","INVALID_JSON","CONNECTION_FAILED","_getValue","_encode","seenObjects","disallowObjects","_hasData","_toPointer","dirty","_toFullJSON","ACL","isDate","__type","iso","GeoPoint","x","isRegExp","Relation","Op","File","_objectEach","v","k","_decode","_arrayEach","__op","pointer","_create","_finishFetch","latitude","longitude","relation","targetClassName","file","_url","_traverse","attributes","newChild","_each","callback","_isNullOrUndefined","async","hasLocalStorage","localStorage","setItem","removeItem","getItem","clear","AsyncStorage","p","err","removeItemAsync","memMap","inMemoryMap","Analytics","track","dimensions","val","Config","_escapedAttributes","current","_currentConfig","config","configData","_CURRENT_CONFIG_KEY","get","request","params","errorObject","attr","html","escaped","serverData","message","OTHER_CAUSE","INTERNAL_SERVER_ERROR","OBJECT_NOT_FOUND","INVALID_QUERY","INVALID_CLASS_NAME","MISSING_OBJECT_ID","INVALID_KEY_NAME","INVALID_POINTER","COMMAND_UNAVAILABLE","NOT_INITIALIZED","INCORRECT_TYPE","INVALID_CHANNEL_NAME","PUSH_MISCONFIGURED","OBJECT_TOO_LARGE","OPERATION_FORBIDDEN","CACHE_MISS","INVALID_NESTED_KEY","INVALID_FILE_NAME","INVALID_ACL","TIMEOUT","INVALID_EMAIL_ADDRESS","MISSING_CONTENT_TYPE","MISSING_CONTENT_LENGTH","INVALID_CONTENT_LENGTH","FILE_TOO_LARGE","FILE_SAVE_ERROR","DUPLICATE_VALUE","INVALID_ROLE_NAME","EXCEEDED_QUOTA","SCRIPT_FAILED","VALIDATION_ERROR","INVALID_IMAGE_DATA","UNSAVED_FILE_ERROR","INVALID_PUSH_TIME_ERROR","FILE_DELETE_ERROR","REQUEST_LIMIT_EXCEEDED","INVALID_EVENT_NAME","USERNAME_MISSING","PASSWORD_MISSING","USERNAME_TAKEN","EMAIL_TAKEN","EMAIL_MISSING","EMAIL_NOT_FOUND","SESSION_MISSING","MUST_CREATE_USER_THROUGH_SIGNUP","ACCOUNT_ALREADY_LINKED","INVALID_SESSION_TOKEN","LINKED_ID_MISSING","INVALID_LINKED_SESSION","UNSUPPORTED_SERVICE","AGGREGATE_ERROR","FILE_READ_ERROR","eventSplitter","Events","on","events","calls","event","split","_callbacks","shift","next","off","ctx","trigger","unbind","arg1","arg2","_validate","__defineGetter__","__defineSetter__","_latitude","_longitude","navigator","geolocation","getCurrentPosition","location","coords","radiansTo","point","d2r","PI","lat1rad","long1rad","lat2rad","long2rad","deltaLat","deltaLong","sinDeltaLatDiv2","sin","sinDeltaLongDiv2","cos","asin","sqrt","kilometersTo","milesTo","PUBLIC_KEY","permissionsById","setReadAccess","setWriteAccess","accessList","userId","allowed","permission","_setAccess","accessType","Role","getName","permissions","_getAccess","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","getRoleReadAccess","role","getRoleWriteAccess","setRoleReadAccess","setRoleWriteAccess","_opDecoderMap","_registerDecoder","opName","decoder","json","op","ops","nextOp","_mergeWithPrevious","Set","_value","_estimate","oldValue","_UNSET","Unset","Increment","amount","_amount","Add","objects","_objects","undefined","AddUnique","newValue","matchingObj","anObj","Remove","adds","removes","_targetClassName","pointerToId","relationsToAdd","relationsToRemove","added","removed","idToPointer","pointers","newAdd","newRemove","newRelation","_ensureParentAndKey","add","change","remove","query","targetClass","_getSubclass","Query","_extraOptions","redirectClassNameForKey","_addCondition","_resolved","_rejected","_resolvedCallbacks","_rejectedCallbacks","_isPromisesAPlusCompliant","is","when","promises","total","hadError","errors","resolveOne","_continueWhile","asyncFunction","_result","resolvedCallback","_error","rejectedCallback","wrappedResolvedCallback","wrappedRejectedCallback","runLater","window","nextTick","always","done","optionsOrCallback","model","_continueWith","continuation","b64Digit","number","fromCharCode","encodeBase64","chunks","b1","b2","b3","has2","has3","readAsync","reader","FileReader","onloadend","dataURL","readAsDataURL","_name","extension","toLowerCase","specifiedType","_source","base64","dataUriRegexp","save","_previousSave","_ContentType","_serverData","_opSetQueue","_hashedJSON","cid","changed","_silent","_pending","silent","_previousAttributes","saveAll","_deepSaveAsync","destroyAll","triggerDestroy","destroyBatch","batch","requests","responses","thisBatch","fetchAll","_fetchAll","fetchAllIfNeeded","_existed","_operations","createdAt","updatedAt","_refreshCache","_refreshingCache","objectArray","arrVal","_resetCacheForKey","currentChanges","dirtyKeys","_mergeMagicFields","specialFields","_copyServerData","tempServerData","_rebuildAllEstimatedData","_mergeFromObject","_startSave","_cancelSave","failedChanges","nextChanges","op1","op2","_saving","_finishSave","fetchedObjects","savedChanges","_applyOpSet","fetched","hasData","opSet","target","wasSet","_rebuildEstimatedDataForKey","previousAttributes","unusedValue","readOnlyAttributes","unset","dataToValidate","changes","isRealChange","increment","addUnique","keysToClear","_getSaveJSON","_canBeSerialized","_canBeSerializedAsValue","fetch","arg3","extraKeys","allFunctions","setOptions","setError","unsavedChildren","unsavedFiles","_findUnsavedChildren","_allPreviousSaves","resp","serverAttrs","destroy","isNew","changing","_changing","deleteChanged","existed","hasChanged","changedAttributes","diff","old","diffVal","isValid","validate","correct","getACL","setACL","acl","ObjectClass","_classMap","_toObjectIdArray","omitObjectsWithData","objectIds","_updateWithFetchedResults","forceFetch","fetchedObjectsById","fetchedObject","containedIn","limit","_performUserRewrite","NewClassObject","OldClassObject","arg0","newArguments","createWithoutData","children","files","canBeSerializedAsValue","newRemaining","readyToStart","batchFinished","body","setName","getUsers","getRoles","newName","Collection","models","comparator","_reset","reset","cids","ids","_prepareModel","_byCid","_byId","_onModelEvent","at","splice","getByCid","_removeReference","boundComparator","coll","nextModel","ModelConstructor","ev","View","_configure","_ensureElement","delegateEvents","viewOptions","tagName","selector","$el","make","content","el","document","createElement","setElement","element","delegate","undelegateEvents","eventName","_isCurrentUser","getSessionToken","_cleanupAuthData","isCurrent","authData","_synchronizeAllAuthData","_synchronizeAuthData","provider","authType","_authProviders","getAuthType","restoreAuthentication","_unlinkFrom","_handleSaveResult","makeCurrent","password","_saveCurrentUser","_linkWith","newOptions","authenticate","_isLinked","_logOutWithAll","_logOutWith","deauthenticate","signUp","username","logIn","getUsername","setUsername","setPassword","getEmail","setEmail","email","authenticated","_upgradeToRevocableSession","currentSession","Session","_isRevocable","session","_currentUser","_currentUserMatchesDisk","_CURRENT_USER_KEY","_enableUnsafeCurrentUser","user","become","logOut","requestPasswordReset","userData","_id","allowCustomUserClass","isAllowed","enableRevocableSession","enableUnsafeCurrentUser","_registerAuthenticationProvider","_logInWith","createdWith","expiresAt","installationId","restricted","currentToken","token","isCurrentSessionRevocable","objectClass","_where","_include","_limit","_skip","or","queries","q","_orQuery","equalTo","firstOptions","_select","skip","_order","order","ObjectConstructor","count","items","doesNotExist","condition","notEqualTo","lessThan","greaterThan","lessThanOrEqualTo","greaterThanOrEqualTo","notContainedIn","containsAll","exists","regex","modifiers","ignoreCase","multiline","matchesQuery","queryJSON","doesNotMatchQuery","matchesKeyInQuery","queryKey","doesNotMatchKeyInQuery","$or","_quote","s","startsWith","endsWith","ascending","addAscending","descending","addDescending","near","withinRadians","distance","withinMiles","withinKilometers","withinGeoBox","southwest","northeast","$box","batchSize","findOptions","finished","callbacksDone","requestedPermissions","initOptions","initialized","FB","login","authResponse","userID","access_token","accessToken","expiration_date","expiresIn","scope","existingResponse","getAuthResponse","logout","init","FacebookUtils","warn","console","log","isLinked","link","unlink","History","handlers","routeStripper","isExplorer","started","interval","getHash","windowOverride","loc","href","getFragment","fragment","forcePushState","_hasPushState","pathname","search","substr","_wantsHashChange","hashChange","_wantsPushState","pushState","history","docMode","documentMode","oldIE","userAgent","iframe","hide","appendTo","contentWindow","navigate","checkUrl","_checkUrlInterval","setInterval","atRoot","hash","replaceState","title","protocol","host","loadUrl","clearInterval","unshift","fragmentOverride","matched","handler","frag","replaceOrPush","_updateHash","close","Router","routes","_bindRoutes","namedParam","splatParam","escapeRegExp","_routeToRegExp","_extractParameters","run","Installation","Push","push_time","expiration_time","expiration_interval"],"mappings":"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","file":"parsebone.min.js","sourcesContent":["/* global define */\n\n/*!\n * Parse JavaScript SDK\n * Version: 1.5.0\n * Built: Fri Jul 10 2015 17:05:46\n * http://parse.com\n *\n * Copyright 2015 Parse, LLC\n *\n * Includes: Underscore.js\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT license.\n */\nvar moduleExport\n\nif ((typeof define === 'function' && define.amd) || (typeof module === 'object' && module.exports)) {\n  moduleExport = {}\n} else {\n  moduleExport = this\n}\n\n;(function () {\n  this.Parse = {}\n  this.Parse.VERSION = 'js1.5.0'\n\n  /* eslint-disable semi */\n  ; // Added so that the syntax for the self executing functions in the Underscore module is correct\n  /* eslint-enable semi */\n\n  //     Underscore.js 1.8.3\n  //     http://underscorejs.org\n  //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n  //     Underscore may be freely distributed under the MIT license.\n  \n  (function() {\n  \n    // Baseline setup\n    // --------------\n  \n    // Establish the root object, `window` in the browser, or `exports` on the server.\n    var root = this;\n  \n    // Save the previous value of the `_` variable.\n    var previousUnderscore = root._;\n  \n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n  \n    // Create quick reference variables for speed access to core prototypes.\n    var\n      push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n  \n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var\n      nativeIsArray      = Array.isArray,\n      nativeKeys         = Object.keys,\n      nativeBind         = FuncProto.bind,\n      nativeCreate       = Object.create;\n  \n    // Naked function reference for surrogate-prototype-swapping.\n    var Ctor = function(){};\n  \n    // Create a safe reference to the Underscore object for use below.\n    var _ = function(obj) {\n      if (obj instanceof _) return obj;\n      if (!(this instanceof _)) return new _(obj);\n      this._wrapped = obj;\n    };\n  \n    // Export the Underscore object for **Node.js**, with\n    // backwards-compatibility for the old `require()` API. If we're in\n    // the browser, add `_` as a global object.\n    if (typeof exports !== 'undefined') {\n      if (typeof module !== 'undefined' && module.exports) {\n        exports = module.exports = _;\n      }\n      exports._ = _;\n    } else {\n      root._ = _;\n    }\n  \n    // Current version.\n    _.VERSION = '1.8.3';\n  \n    // Internal function that returns an efficient (for current engines) version\n    // of the passed-in callback, to be repeatedly applied in other Underscore\n    // functions.\n    var optimizeCb = function(func, context, argCount) {\n      if (context === void 0) return func;\n      switch (argCount == null ? 3 : argCount) {\n        case 1: return function(value) {\n          return func.call(context, value);\n        };\n        case 2: return function(value, other) {\n          return func.call(context, value, other);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(context, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(context, accumulator, value, index, collection);\n        };\n      }\n      return function() {\n        return func.apply(context, arguments);\n      };\n    };\n  \n    // A mostly-internal function to generate callbacks that can be applied\n    // to each element in a collection, returning the desired result — either\n    // identity, an arbitrary callback, a property matcher, or a property accessor.\n    var cb = function(value, context, argCount) {\n      if (value == null) return _.identity;\n      if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n      if (_.isObject(value)) return _.matcher(value);\n      return _.property(value);\n    };\n    _.iteratee = function(value, context) {\n      return cb(value, context, Infinity);\n    };\n  \n    // An internal function for creating assigner functions.\n    var createAssigner = function(keysFunc, undefinedOnly) {\n      return function(obj) {\n        var length = arguments.length;\n        if (length < 2 || obj == null) return obj;\n        for (var index = 1; index < length; index++) {\n          var source = arguments[index],\n              keys = keysFunc(source),\n              l = keys.length;\n          for (var i = 0; i < l; i++) {\n            var key = keys[i];\n            if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n          }\n        }\n        return obj;\n      };\n    };\n  \n    // An internal function for creating a new object that inherits from another.\n    var baseCreate = function(prototype) {\n      if (!_.isObject(prototype)) return {};\n      if (nativeCreate) return nativeCreate(prototype);\n      Ctor.prototype = prototype;\n      var result = new Ctor;\n      Ctor.prototype = null;\n      return result;\n    };\n  \n    var property = function(key) {\n      return function(obj) {\n        return obj == null ? void 0 : obj[key];\n      };\n    };\n  \n    // Helper for collection methods to determine whether a collection\n    // should be iterated as an array or as an object\n    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n    var getLength = property('length');\n    var isArrayLike = function(collection) {\n      var length = getLength(collection);\n      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n    };\n  \n    // Collection Functions\n    // --------------------\n  \n    // The cornerstone, an `each` implementation, aka `forEach`.\n    // Handles raw objects in addition to array-likes. Treats all\n    // sparse array-likes as if they were dense.\n    _.each = _.forEach = function(obj, iteratee, context) {\n      iteratee = optimizeCb(iteratee, context);\n      var i, length;\n      if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n          iteratee(obj[i], i, obj);\n        }\n      } else {\n        var keys = _.keys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n          iteratee(obj[keys[i]], keys[i], obj);\n        }\n      }\n      return obj;\n    };\n  \n    // Return the results of applying the iteratee to each element.\n    _.map = _.collect = function(obj, iteratee, context) {\n      iteratee = cb(iteratee, context);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          results = Array(length);\n      for (var index = 0; index < length; index++) {\n        var currentKey = keys ? keys[index] : index;\n        results[index] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n    };\n  \n    // Create a reducing function iterating left or right.\n    function createReduce(dir) {\n      // Optimized iterator function as using arguments.length\n      // in the main function will deoptimize the, see #1991.\n      function iterator(obj, iteratee, memo, keys, index, length) {\n        for (; index >= 0 && index < length; index += dir) {\n          var currentKey = keys ? keys[index] : index;\n          memo = iteratee(memo, obj[currentKey], currentKey, obj);\n        }\n        return memo;\n      }\n  \n      return function(obj, iteratee, memo, context) {\n        iteratee = optimizeCb(iteratee, context, 4);\n        var keys = !isArrayLike(obj) && _.keys(obj),\n            length = (keys || obj).length,\n            index = dir > 0 ? 0 : length - 1;\n        // Determine the initial value if none is provided.\n        if (arguments.length < 3) {\n          memo = obj[keys ? keys[index] : index];\n          index += dir;\n        }\n        return iterator(obj, iteratee, memo, keys, index, length);\n      };\n    }\n  \n    // **Reduce** builds up a single result from a list of values, aka `inject`,\n    // or `foldl`.\n    _.reduce = _.foldl = _.inject = createReduce(1);\n  \n    // The right-associative version of reduce, also known as `foldr`.\n    _.reduceRight = _.foldr = createReduce(-1);\n  \n    // Return the first value which passes a truth test. Aliased as `detect`.\n    _.find = _.detect = function(obj, predicate, context) {\n      var key;\n      if (isArrayLike(obj)) {\n        key = _.findIndex(obj, predicate, context);\n      } else {\n        key = _.findKey(obj, predicate, context);\n      }\n      if (key !== void 0 && key !== -1) return obj[key];\n    };\n  \n    // Return all the elements that pass a truth test.\n    // Aliased as `select`.\n    _.filter = _.select = function(obj, predicate, context) {\n      var results = [];\n      predicate = cb(predicate, context);\n      _.each(obj, function(value, index, list) {\n        if (predicate(value, index, list)) results.push(value);\n      });\n      return results;\n    };\n  \n    // Return all the elements for which a truth test fails.\n    _.reject = function(obj, predicate, context) {\n      return _.filter(obj, _.negate(cb(predicate)), context);\n    };\n  \n    // Determine whether all of the elements match a truth test.\n    // Aliased as `all`.\n    _.every = _.all = function(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length;\n      for (var index = 0; index < length; index++) {\n        var currentKey = keys ? keys[index] : index;\n        if (!predicate(obj[currentKey], currentKey, obj)) return false;\n      }\n      return true;\n    };\n  \n    // Determine if at least one element in the object matches a truth test.\n    // Aliased as `any`.\n    _.some = _.any = function(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length;\n      for (var index = 0; index < length; index++) {\n        var currentKey = keys ? keys[index] : index;\n        if (predicate(obj[currentKey], currentKey, obj)) return true;\n      }\n      return false;\n    };\n  \n    // Determine if the array or object contains a given item (using `===`).\n    // Aliased as `includes` and `include`.\n    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n      return _.indexOf(obj, item, fromIndex) >= 0;\n    };\n  \n    // Invoke a method (with arguments) on every item in a collection.\n    _.invoke = function(obj, method) {\n      var args = slice.call(arguments, 2);\n      var isFunc = _.isFunction(method);\n      return _.map(obj, function(value) {\n        var func = isFunc ? method : value[method];\n        return func == null ? func : func.apply(value, args);\n      });\n    };\n  \n    // Convenience version of a common use case of `map`: fetching a property.\n    _.pluck = function(obj, key) {\n      return _.map(obj, _.property(key));\n    };\n  \n    // Convenience version of a common use case of `filter`: selecting only objects\n    // containing specific `key:value` pairs.\n    _.where = function(obj, attrs) {\n      return _.filter(obj, _.matcher(attrs));\n    };\n  \n    // Convenience version of a common use case of `find`: getting the first object\n    // containing specific `key:value` pairs.\n    _.findWhere = function(obj, attrs) {\n      return _.find(obj, _.matcher(attrs));\n    };\n  \n    // Return the maximum element (or element-based computation).\n    _.max = function(obj, iteratee, context) {\n      var result = -Infinity, lastComputed = -Infinity,\n          value, computed;\n      if (iteratee == null && obj != null) {\n        obj = isArrayLike(obj) ? obj : _.values(obj);\n        for (var i = 0, length = obj.length; i < length; i++) {\n          value = obj[i];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        iteratee = cb(iteratee, context);\n        _.each(obj, function(value, index, list) {\n          computed = iteratee(value, index, list);\n          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n            result = value;\n            lastComputed = computed;\n          }\n        });\n      }\n      return result;\n    };\n  \n    // Return the minimum element (or element-based computation).\n    _.min = function(obj, iteratee, context) {\n      var result = Infinity, lastComputed = Infinity,\n          value, computed;\n      if (iteratee == null && obj != null) {\n        obj = isArrayLike(obj) ? obj : _.values(obj);\n        for (var i = 0, length = obj.length; i < length; i++) {\n          value = obj[i];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        iteratee = cb(iteratee, context);\n        _.each(obj, function(value, index, list) {\n          computed = iteratee(value, index, list);\n          if (computed < lastComputed || computed === Infinity && result === Infinity) {\n            result = value;\n            lastComputed = computed;\n          }\n        });\n      }\n      return result;\n    };\n  \n    // Shuffle a collection, using the modern version of the\n    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n    _.shuffle = function(obj) {\n      var set = isArrayLike(obj) ? obj : _.values(obj);\n      var length = set.length;\n      var shuffled = Array(length);\n      for (var index = 0, rand; index < length; index++) {\n        rand = _.random(0, index);\n        if (rand !== index) shuffled[index] = shuffled[rand];\n        shuffled[rand] = set[index];\n      }\n      return shuffled;\n    };\n  \n    // Sample **n** random values from a collection.\n    // If **n** is not specified, returns a single random element.\n    // The internal `guard` argument allows it to work with `map`.\n    _.sample = function(obj, n, guard) {\n      if (n == null || guard) {\n        if (!isArrayLike(obj)) obj = _.values(obj);\n        return obj[_.random(obj.length - 1)];\n      }\n      return _.shuffle(obj).slice(0, Math.max(0, n));\n    };\n  \n    // Sort the object's values by a criterion produced by an iteratee.\n    _.sortBy = function(obj, iteratee, context) {\n      iteratee = cb(iteratee, context);\n      return _.pluck(_.map(obj, function(value, index, list) {\n        return {\n          value: value,\n          index: index,\n          criteria: iteratee(value, index, list)\n        };\n      }).sort(function(left, right) {\n        var a = left.criteria;\n        var b = right.criteria;\n        if (a !== b) {\n          if (a > b || a === void 0) return 1;\n          if (a < b || b === void 0) return -1;\n        }\n        return left.index - right.index;\n      }), 'value');\n    };\n  \n    // An internal function used for aggregate \"group by\" operations.\n    var group = function(behavior) {\n      return function(obj, iteratee, context) {\n        var result = {};\n        iteratee = cb(iteratee, context);\n        _.each(obj, function(value, index) {\n          var key = iteratee(value, index, obj);\n          behavior(result, value, key);\n        });\n        return result;\n      };\n    };\n  \n    // Groups the object's values by a criterion. Pass either a string attribute\n    // to group by, or a function that returns the criterion.\n    _.groupBy = group(function(result, value, key) {\n      if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n    });\n  \n    // Indexes the object's values by a criterion, similar to `groupBy`, but for\n    // when you know that your index values will be unique.\n    _.indexBy = group(function(result, value, key) {\n      result[key] = value;\n    });\n  \n    // Counts instances of an object that group by a certain criterion. Pass\n    // either a string attribute to count by, or a function that returns the\n    // criterion.\n    _.countBy = group(function(result, value, key) {\n      if (_.has(result, key)) result[key]++; else result[key] = 1;\n    });\n  \n    // Safely create a real, live array from anything iterable.\n    _.toArray = function(obj) {\n      if (!obj) return [];\n      if (_.isArray(obj)) return slice.call(obj);\n      if (isArrayLike(obj)) return _.map(obj, _.identity);\n      return _.values(obj);\n    };\n  \n    // Return the number of elements in an object.\n    _.size = function(obj) {\n      if (obj == null) return 0;\n      return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n    };\n  \n    // Split a collection into two arrays: one whose elements all satisfy the given\n    // predicate, and one whose elements all do not satisfy the predicate.\n    _.partition = function(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var pass = [], fail = [];\n      _.each(obj, function(value, key, obj) {\n        (predicate(value, key, obj) ? pass : fail).push(value);\n      });\n      return [pass, fail];\n    };\n  \n    // Array Functions\n    // ---------------\n  \n    // Get the first element of an array. Passing **n** will return the first N\n    // values in the array. Aliased as `head` and `take`. The **guard** check\n    // allows it to work with `_.map`.\n    _.first = _.head = _.take = function(array, n, guard) {\n      if (array == null) return void 0;\n      if (n == null || guard) return array[0];\n      return _.initial(array, array.length - n);\n    };\n  \n    // Returns everything but the last entry of the array. Especially useful on\n    // the arguments object. Passing **n** will return all the values in\n    // the array, excluding the last N.\n    _.initial = function(array, n, guard) {\n      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n    };\n  \n    // Get the last element of an array. Passing **n** will return the last N\n    // values in the array.\n    _.last = function(array, n, guard) {\n      if (array == null) return void 0;\n      if (n == null || guard) return array[array.length - 1];\n      return _.rest(array, Math.max(0, array.length - n));\n    };\n  \n    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n    // Especially useful on the arguments object. Passing an **n** will return\n    // the rest N values in the array.\n    _.rest = _.tail = _.drop = function(array, n, guard) {\n      return slice.call(array, n == null || guard ? 1 : n);\n    };\n  \n    // Trim out all falsy values from an array.\n    _.compact = function(array) {\n      return _.filter(array, _.identity);\n    };\n  \n    // Internal implementation of a recursive `flatten` function.\n    var flatten = function(input, shallow, strict, startIndex) {\n      var output = [], idx = 0;\n      for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n        var value = input[i];\n        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n          //flatten current level of array or arguments object\n          if (!shallow) value = flatten(value, shallow, strict);\n          var j = 0, len = value.length;\n          output.length += len;\n          while (j < len) {\n            output[idx++] = value[j++];\n          }\n        } else if (!strict) {\n          output[idx++] = value;\n        }\n      }\n      return output;\n    };\n  \n    // Flatten out an array, either recursively (by default), or just one level.\n    _.flatten = function(array, shallow) {\n      return flatten(array, shallow, false);\n    };\n  \n    // Return a version of the array that does not contain the specified value(s).\n    _.without = function(array) {\n      return _.difference(array, slice.call(arguments, 1));\n    };\n  \n    // Produce a duplicate-free version of the array. If the array has already\n    // been sorted, you have the option of using a faster algorithm.\n    // Aliased as `unique`.\n    _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n      if (!_.isBoolean(isSorted)) {\n        context = iteratee;\n        iteratee = isSorted;\n        isSorted = false;\n      }\n      if (iteratee != null) iteratee = cb(iteratee, context);\n      var result = [];\n      var seen = [];\n      for (var i = 0, length = getLength(array); i < length; i++) {\n        var value = array[i],\n            computed = iteratee ? iteratee(value, i, array) : value;\n        if (isSorted) {\n          if (!i || seen !== computed) result.push(value);\n          seen = computed;\n        } else if (iteratee) {\n          if (!_.contains(seen, computed)) {\n            seen.push(computed);\n            result.push(value);\n          }\n        } else if (!_.contains(result, value)) {\n          result.push(value);\n        }\n      }\n      return result;\n    };\n  \n    // Produce an array that contains the union: each distinct element from all of\n    // the passed-in arrays.\n    _.union = function() {\n      return _.uniq(flatten(arguments, true, true));\n    };\n  \n    // Produce an array that contains every item shared between all the\n    // passed-in arrays.\n    _.intersection = function(array) {\n      var result = [];\n      var argsLength = arguments.length;\n      for (var i = 0, length = getLength(array); i < length; i++) {\n        var item = array[i];\n        if (_.contains(result, item)) continue;\n        for (var j = 1; j < argsLength; j++) {\n          if (!_.contains(arguments[j], item)) break;\n        }\n        if (j === argsLength) result.push(item);\n      }\n      return result;\n    };\n  \n    // Take the difference between one array and a number of other arrays.\n    // Only the elements present in just the first array will remain.\n    _.difference = function(array) {\n      var rest = flatten(arguments, true, true, 1);\n      return _.filter(array, function(value){\n        return !_.contains(rest, value);\n      });\n    };\n  \n    // Zip together multiple lists into a single array -- elements that share\n    // an index go together.\n    _.zip = function() {\n      return _.unzip(arguments);\n    };\n  \n    // Complement of _.zip. Unzip accepts an array of arrays and groups\n    // each array's elements on shared indices\n    _.unzip = function(array) {\n      var length = array && _.max(array, getLength).length || 0;\n      var result = Array(length);\n  \n      for (var index = 0; index < length; index++) {\n        result[index] = _.pluck(array, index);\n      }\n      return result;\n    };\n  \n    // Converts lists into objects. Pass either a single array of `[key, value]`\n    // pairs, or two parallel arrays of the same length -- one of keys, and one of\n    // the corresponding values.\n    _.object = function(list, values) {\n      var result = {};\n      for (var i = 0, length = getLength(list); i < length; i++) {\n        if (values) {\n          result[list[i]] = values[i];\n        } else {\n          result[list[i][0]] = list[i][1];\n        }\n      }\n      return result;\n    };\n  \n    // Generator function to create the findIndex and findLastIndex functions\n    function createPredicateIndexFinder(dir) {\n      return function(array, predicate, context) {\n        predicate = cb(predicate, context);\n        var length = getLength(array);\n        var index = dir > 0 ? 0 : length - 1;\n        for (; index >= 0 && index < length; index += dir) {\n          if (predicate(array[index], index, array)) return index;\n        }\n        return -1;\n      };\n    }\n  \n    // Returns the first index on an array-like that passes a predicate test\n    _.findIndex = createPredicateIndexFinder(1);\n    _.findLastIndex = createPredicateIndexFinder(-1);\n  \n    // Use a comparator function to figure out the smallest index at which\n    // an object should be inserted so as to maintain order. Uses binary search.\n    _.sortedIndex = function(array, obj, iteratee, context) {\n      iteratee = cb(iteratee, context, 1);\n      var value = iteratee(obj);\n      var low = 0, high = getLength(array);\n      while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n      }\n      return low;\n    };\n  \n    // Generator function to create the indexOf and lastIndexOf functions\n    function createIndexFinder(dir, predicateFind, sortedIndex) {\n      return function(array, item, idx) {\n        var i = 0, length = getLength(array);\n        if (typeof idx == 'number') {\n          if (dir > 0) {\n              i = idx >= 0 ? idx : Math.max(idx + length, i);\n          } else {\n              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n          }\n        } else if (sortedIndex && idx && length) {\n          idx = sortedIndex(array, item);\n          return array[idx] === item ? idx : -1;\n        }\n        if (item !== item) {\n          idx = predicateFind(slice.call(array, i, length), _.isNaN);\n          return idx >= 0 ? idx + i : -1;\n        }\n        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n          if (array[idx] === item) return idx;\n        }\n        return -1;\n      };\n    }\n  \n    // Return the position of the first occurrence of an item in an array,\n    // or -1 if the item is not included in the array.\n    // If the array is large and already in sort order, pass `true`\n    // for **isSorted** to use binary search.\n    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n  \n    // Generate an integer Array containing an arithmetic progression. A port of\n    // the native Python `range()` function. See\n    // [the Python documentation](http://docs.python.org/library/functions.html#range).\n    _.range = function(start, stop, step) {\n      if (stop == null) {\n        stop = start || 0;\n        start = 0;\n      }\n      step = step || 1;\n  \n      var length = Math.max(Math.ceil((stop - start) / step), 0);\n      var range = Array(length);\n  \n      for (var idx = 0; idx < length; idx++, start += step) {\n        range[idx] = start;\n      }\n  \n      return range;\n    };\n  \n    // Function (ahem) Functions\n    // ------------------\n  \n    // Determines whether to execute a function as a constructor\n    // or a normal function with the provided arguments\n    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n      var self = baseCreate(sourceFunc.prototype);\n      var result = sourceFunc.apply(self, args);\n      if (_.isObject(result)) return result;\n      return self;\n    };\n  \n    // Create a function bound to a given object (assigning `this`, and arguments,\n    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n    // available.\n    _.bind = function(func, context) {\n      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n      var args = slice.call(arguments, 2);\n      var bound = function() {\n        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n      };\n      return bound;\n    };\n  \n    // Partially apply a function by creating a version that has had some of its\n    // arguments pre-filled, without changing its dynamic `this` context. _ acts\n    // as a placeholder, allowing any combination of arguments to be pre-filled.\n    _.partial = function(func) {\n      var boundArgs = slice.call(arguments, 1);\n      var bound = function() {\n        var position = 0, length = boundArgs.length;\n        var args = Array(length);\n        for (var i = 0; i < length; i++) {\n          args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n        }\n        while (position < arguments.length) args.push(arguments[position++]);\n        return executeBound(func, bound, this, this, args);\n      };\n      return bound;\n    };\n  \n    // Bind a number of an object's methods to that object. Remaining arguments\n    // are the method names to be bound. Useful for ensuring that all callbacks\n    // defined on an object belong to it.\n    _.bindAll = function(obj) {\n      var i, length = arguments.length, key;\n      if (length <= 1) throw new Error('bindAll must be passed function names');\n      for (i = 1; i < length; i++) {\n        key = arguments[i];\n        obj[key] = _.bind(obj[key], obj);\n      }\n      return obj;\n    };\n  \n    // Memoize an expensive function by storing its results.\n    _.memoize = function(func, hasher) {\n      var memoize = function(key) {\n        var cache = memoize.cache;\n        var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n        if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n        return cache[address];\n      };\n      memoize.cache = {};\n      return memoize;\n    };\n  \n    // Delays a function for the given number of milliseconds, and then calls\n    // it with the arguments supplied.\n    _.delay = function(func, wait) {\n      var args = slice.call(arguments, 2);\n      return setTimeout(function(){\n        return func.apply(null, args);\n      }, wait);\n    };\n  \n    // Defers a function, scheduling it to run after the current call stack has\n    // cleared.\n    _.defer = _.partial(_.delay, _, 1);\n  \n    // Returns a function, that, when invoked, will only be triggered at most once\n    // during a given window of time. Normally, the throttled function will run\n    // as much as it can, without ever going more than once per `wait` duration;\n    // but if you'd like to disable the execution on the leading edge, pass\n    // `{leading: false}`. To disable execution on the trailing edge, ditto.\n    _.throttle = function(func, wait, options) {\n      var context, args, result;\n      var timeout = null;\n      var previous = 0;\n      if (!options) options = {};\n      var later = function() {\n        previous = options.leading === false ? 0 : _.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function() {\n        var now = _.now();\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n          timeout = setTimeout(later, remaining);\n        }\n        return result;\n      };\n    };\n  \n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds. If `immediate` is passed, trigger the function on the\n    // leading edge, instead of the trailing.\n    _.debounce = function(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n  \n      var later = function() {\n        var last = _.now() - timestamp;\n  \n        if (last < wait && last >= 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n  \n      return function() {\n        context = this;\n        args = arguments;\n        timestamp = _.now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n  \n        return result;\n      };\n    };\n  \n    // Returns the first function passed as an argument to the second,\n    // allowing you to adjust arguments, run code before and after, and\n    // conditionally execute the original function.\n    _.wrap = function(func, wrapper) {\n      return _.partial(wrapper, func);\n    };\n  \n    // Returns a negated version of the passed-in predicate.\n    _.negate = function(predicate) {\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    };\n  \n    // Returns a function that is the composition of a list of functions, each\n    // consuming the return value of the function that follows.\n    _.compose = function() {\n      var args = arguments;\n      var start = args.length - 1;\n      return function() {\n        var i = start;\n        var result = args[start].apply(this, arguments);\n        while (i--) result = args[i].call(this, result);\n        return result;\n      };\n    };\n  \n    // Returns a function that will only be executed on and after the Nth call.\n    _.after = function(times, func) {\n      return function() {\n        if (--times < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    };\n  \n    // Returns a function that will only be executed up to (but not including) the Nth call.\n    _.before = function(times, func) {\n      var memo;\n      return function() {\n        if (--times > 0) {\n          memo = func.apply(this, arguments);\n        }\n        if (times <= 1) func = null;\n        return memo;\n      };\n    };\n  \n    // Returns a function that will be executed at most one time, no matter how\n    // often you call it. Useful for lazy initialization.\n    _.once = _.partial(_.before, 2);\n  \n    // Object Functions\n    // ----------------\n  \n    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                        'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n  \n    function collectNonEnumProps(obj, keys) {\n      var nonEnumIdx = nonEnumerableProps.length;\n      var constructor = obj.constructor;\n      var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n  \n      // Constructor is a special case.\n      var prop = 'constructor';\n      if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n  \n      while (nonEnumIdx--) {\n        prop = nonEnumerableProps[nonEnumIdx];\n        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n          keys.push(prop);\n        }\n      }\n    }\n  \n    // Retrieve the names of an object's own properties.\n    // Delegates to **ECMAScript 5**'s native `Object.keys`\n    _.keys = function(obj) {\n      if (!_.isObject(obj)) return [];\n      if (nativeKeys) return nativeKeys(obj);\n      var keys = [];\n      for (var key in obj) if (_.has(obj, key)) keys.push(key);\n      // Ahem, IE < 9.\n      if (hasEnumBug) collectNonEnumProps(obj, keys);\n      return keys;\n    };\n  \n    // Retrieve all the property names of an object.\n    _.allKeys = function(obj) {\n      if (!_.isObject(obj)) return [];\n      var keys = [];\n      for (var key in obj) keys.push(key);\n      // Ahem, IE < 9.\n      if (hasEnumBug) collectNonEnumProps(obj, keys);\n      return keys;\n    };\n  \n    // Retrieve the values of an object's properties.\n    _.values = function(obj) {\n      var keys = _.keys(obj);\n      var length = keys.length;\n      var values = Array(length);\n      for (var i = 0; i < length; i++) {\n        values[i] = obj[keys[i]];\n      }\n      return values;\n    };\n  \n    // Returns the results of applying the iteratee to each element of the object\n    // In contrast to _.map it returns an object\n    _.mapObject = function(obj, iteratee, context) {\n      iteratee = cb(iteratee, context);\n      var keys =  _.keys(obj),\n            length = keys.length,\n            results = {},\n            currentKey;\n        for (var index = 0; index < length; index++) {\n          currentKey = keys[index];\n          results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n        }\n        return results;\n    };\n  \n    // Convert an object into a list of `[key, value]` pairs.\n    _.pairs = function(obj) {\n      var keys = _.keys(obj);\n      var length = keys.length;\n      var pairs = Array(length);\n      for (var i = 0; i < length; i++) {\n        pairs[i] = [keys[i], obj[keys[i]]];\n      }\n      return pairs;\n    };\n  \n    // Invert the keys and values of an object. The values must be serializable.\n    _.invert = function(obj) {\n      var result = {};\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        result[obj[keys[i]]] = keys[i];\n      }\n      return result;\n    };\n  \n    // Return a sorted list of the function names available on the object.\n    // Aliased as `methods`\n    _.functions = _.methods = function(obj) {\n      var names = [];\n      for (var key in obj) {\n        if (_.isFunction(obj[key])) names.push(key);\n      }\n      return names.sort();\n    };\n  \n    // Extend a given object with all the properties in passed-in object(s).\n    _.extend = createAssigner(_.allKeys);\n  \n    // Assigns a given object with all the own properties in the passed-in object(s)\n    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n    _.extendOwn = _.assign = createAssigner(_.keys);\n  \n    // Returns the first key on an object that passes a predicate test\n    _.findKey = function(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var keys = _.keys(obj), key;\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n        if (predicate(obj[key], key, obj)) return key;\n      }\n    };\n  \n    // Return a copy of the object only containing the whitelisted properties.\n    _.pick = function(object, oiteratee, context) {\n      var result = {}, obj = object, iteratee, keys;\n      if (obj == null) return result;\n      if (_.isFunction(oiteratee)) {\n        keys = _.allKeys(obj);\n        iteratee = optimizeCb(oiteratee, context);\n      } else {\n        keys = flatten(arguments, false, false, 1);\n        iteratee = function(value, key, obj) { return key in obj; };\n        obj = Object(obj);\n      }\n      for (var i = 0, length = keys.length; i < length; i++) {\n        var key = keys[i];\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n      return result;\n    };\n  \n     // Return a copy of the object without the blacklisted properties.\n    _.omit = function(obj, iteratee, context) {\n      if (_.isFunction(iteratee)) {\n        iteratee = _.negate(iteratee);\n      } else {\n        var keys = _.map(flatten(arguments, false, false, 1), String);\n        iteratee = function(value, key) {\n          return !_.contains(keys, key);\n        };\n      }\n      return _.pick(obj, iteratee, context);\n    };\n  \n    // Fill in a given object with default properties.\n    _.defaults = createAssigner(_.allKeys, true);\n  \n    // Creates an object that inherits from the given prototype object.\n    // If additional properties are provided then they will be added to the\n    // created object.\n    _.create = function(prototype, props) {\n      var result = baseCreate(prototype);\n      if (props) _.extendOwn(result, props);\n      return result;\n    };\n  \n    // Create a (shallow-cloned) duplicate of an object.\n    _.clone = function(obj) {\n      if (!_.isObject(obj)) return obj;\n      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n    };\n  \n    // Invokes interceptor with the obj, and then returns obj.\n    // The primary purpose of this method is to \"tap into\" a method chain, in\n    // order to perform operations on intermediate results within the chain.\n    _.tap = function(obj, interceptor) {\n      interceptor(obj);\n      return obj;\n    };\n  \n    // Returns whether an object has a given set of `key:value` pairs.\n    _.isMatch = function(object, attrs) {\n      var keys = _.keys(attrs), length = keys.length;\n      if (object == null) return !length;\n      var obj = Object(object);\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        if (attrs[key] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    };\n  \n  \n    // Internal recursive comparison function for `isEqual`.\n    var eq = function(a, b, aStack, bStack) {\n      // Identical objects are equal. `0 === -0`, but they aren't identical.\n      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n      if (a === b) return a !== 0 || 1 / a === 1 / b;\n      // A strict comparison is necessary because `null == undefined`.\n      if (a == null || b == null) return a === b;\n      // Unwrap any wrapped objects.\n      if (a instanceof _) a = a._wrapped;\n      if (b instanceof _) b = b._wrapped;\n      // Compare `[[Class]]` names.\n      var className = toString.call(a);\n      if (className !== toString.call(b)) return false;\n      switch (className) {\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case '[object String]':\n          // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n          // equivalent to `new String(\"5\")`.\n          return '' + a === '' + b;\n        case '[object Number]':\n          // `NaN`s are equivalent, but non-reflexive.\n          // Object(NaN) is equivalent to NaN\n          if (+a !== +a) return +b !== +b;\n          // An `egal` comparison is performed for other numeric values.\n          return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case '[object Date]':\n        case '[object Boolean]':\n          // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n          // millisecond representations. Note that invalid dates with millisecond representations\n          // of `NaN` are not equivalent.\n          return +a === +b;\n      }\n  \n      var areArrays = className === '[object Array]';\n      if (!areArrays) {\n        if (typeof a != 'object' || typeof b != 'object') return false;\n  \n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                                 _.isFunction(bCtor) && bCtor instanceof bCtor)\n                            && ('constructor' in a && 'constructor' in b)) {\n          return false;\n        }\n      }\n      // Assume equality for cyclic structures. The algorithm for detecting cyclic\n      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n  \n      // Initializing stack of traversed objects.\n      // It's done here since we only need them for objects and arrays comparison.\n      aStack = aStack || [];\n      bStack = bStack || [];\n      var length = aStack.length;\n      while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a) return bStack[length] === b;\n      }\n  \n      // Add the first object to the stack of traversed objects.\n      aStack.push(a);\n      bStack.push(b);\n  \n      // Recursively compare objects and arrays.\n      if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length) return false;\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (length--) {\n          if (!eq(a[length], b[length], aStack, bStack)) return false;\n        }\n      } else {\n        // Deep compare objects.\n        var keys = _.keys(a), key;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (_.keys(b).length !== length) return false;\n        while (length--) {\n          // Deep compare each member\n          key = keys[length];\n          if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n        }\n      }\n      // Remove the first object from the stack of traversed objects.\n      aStack.pop();\n      bStack.pop();\n      return true;\n    };\n  \n    // Perform a deep comparison to check if two objects are equal.\n    _.isEqual = function(a, b) {\n      return eq(a, b);\n    };\n  \n    // Is a given array, string, or object empty?\n    // An \"empty\" object has no enumerable own-properties.\n    _.isEmpty = function(obj) {\n      if (obj == null) return true;\n      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n      return _.keys(obj).length === 0;\n    };\n  \n    // Is a given value a DOM element?\n    _.isElement = function(obj) {\n      return !!(obj && obj.nodeType === 1);\n    };\n  \n    // Is a given value an array?\n    // Delegates to ECMA5's native Array.isArray\n    _.isArray = nativeIsArray || function(obj) {\n      return toString.call(obj) === '[object Array]';\n    };\n  \n    // Is a given variable an object?\n    _.isObject = function(obj) {\n      var type = typeof obj;\n      return type === 'function' || type === 'object' && !!obj;\n    };\n  \n    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n      _['is' + name] = function(obj) {\n        return toString.call(obj) === '[object ' + name + ']';\n      };\n    });\n  \n    // Define a fallback version of the method in browsers (ahem, IE < 9), where\n    // there isn't any inspectable \"Arguments\" type.\n    if (!_.isArguments(arguments)) {\n      _.isArguments = function(obj) {\n        return _.has(obj, 'callee');\n      };\n    }\n  \n    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n    // IE 11 (#1621), and in Safari 8 (#1929).\n    if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n      _.isFunction = function(obj) {\n        return typeof obj == 'function' || false;\n      };\n    }\n  \n    // Is a given object a finite number?\n    _.isFinite = function(obj) {\n      return isFinite(obj) && !isNaN(parseFloat(obj));\n    };\n  \n    // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n    _.isNaN = function(obj) {\n      return _.isNumber(obj) && obj !== +obj;\n    };\n  \n    // Is a given value a boolean?\n    _.isBoolean = function(obj) {\n      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n    };\n  \n    // Is a given value equal to null?\n    _.isNull = function(obj) {\n      return obj === null;\n    };\n  \n    // Is a given variable undefined?\n    _.isUndefined = function(obj) {\n      return obj === void 0;\n    };\n  \n    // Shortcut function for checking if an object has a given property directly\n    // on itself (in other words, not on a prototype).\n    _.has = function(obj, key) {\n      return obj != null && hasOwnProperty.call(obj, key);\n    };\n  \n    // Utility Functions\n    // -----------------\n  \n    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n    // previous owner. Returns a reference to the Underscore object.\n    _.noConflict = function() {\n      root._ = previousUnderscore;\n      return this;\n    };\n  \n    // Keep the identity function around for default iteratees.\n    _.identity = function(value) {\n      return value;\n    };\n  \n    // Predicate-generating functions. Often useful outside of Underscore.\n    _.constant = function(value) {\n      return function() {\n        return value;\n      };\n    };\n  \n    _.noop = function(){};\n  \n    _.property = property;\n  \n    // Generates a function for a given object that returns a given property.\n    _.propertyOf = function(obj) {\n      return obj == null ? function(){} : function(key) {\n        return obj[key];\n      };\n    };\n  \n    // Returns a predicate for checking whether an object has a given set of\n    // `key:value` pairs.\n    _.matcher = _.matches = function(attrs) {\n      attrs = _.extendOwn({}, attrs);\n      return function(obj) {\n        return _.isMatch(obj, attrs);\n      };\n    };\n  \n    // Run a function **n** times.\n    _.times = function(n, iteratee, context) {\n      var accum = Array(Math.max(0, n));\n      iteratee = optimizeCb(iteratee, context, 1);\n      for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n      return accum;\n    };\n  \n    // Return a random integer between min and max (inclusive).\n    _.random = function(min, max) {\n      if (max == null) {\n        max = min;\n        min = 0;\n      }\n      return min + Math.floor(Math.random() * (max - min + 1));\n    };\n  \n    // A (possibly faster) way to get the current timestamp as an integer.\n    _.now = Date.now || function() {\n      return new Date().getTime();\n    };\n  \n     // List of HTML entities for escaping.\n    var escapeMap = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '`': '&#x60;'\n    };\n    var unescapeMap = _.invert(escapeMap);\n  \n    // Functions for escaping and unescaping strings to/from HTML interpolation.\n    var createEscaper = function(map) {\n      var escaper = function(match) {\n        return map[match];\n      };\n      // Regexes for identifying a key that needs to be escaped\n      var source = '(?:' + _.keys(map).join('|') + ')';\n      var testRegexp = RegExp(source);\n      var replaceRegexp = RegExp(source, 'g');\n      return function(string) {\n        string = string == null ? '' : '' + string;\n        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n      };\n    };\n    _.escape = createEscaper(escapeMap);\n    _.unescape = createEscaper(unescapeMap);\n  \n    // If the value of the named `property` is a function then invoke it with the\n    // `object` as context; otherwise, return it.\n    _.result = function(object, property, fallback) {\n      var value = object == null ? void 0 : object[property];\n      if (value === void 0) {\n        value = fallback;\n      }\n      return _.isFunction(value) ? value.call(object) : value;\n    };\n  \n    // Generate a unique integer id (unique within the entire client session).\n    // Useful for temporary DOM ids.\n    var idCounter = 0;\n    _.uniqueId = function(prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n  \n    // By default, Underscore uses ERB-style template delimiters, change the\n    // following template settings to use alternative delimiters.\n    _.templateSettings = {\n      evaluate    : /<%([\\s\\S]+?)%>/g,\n      interpolate : /<%=([\\s\\S]+?)%>/g,\n      escape      : /<%-([\\s\\S]+?)%>/g\n    };\n  \n    // When customizing `templateSettings`, if you don't want to define an\n    // interpolation, evaluation or escaping regex, we need one that is\n    // guaranteed not to match.\n    var noMatch = /(.)^/;\n  \n    // Certain characters need to be escaped so that they can be put into a\n    // string literal.\n    var escapes = {\n      \"'\":      \"'\",\n      '\\\\':     '\\\\',\n      '\\r':     'r',\n      '\\n':     'n',\n      '\\u2028': 'u2028',\n      '\\u2029': 'u2029'\n    };\n  \n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n  \n    var escapeChar = function(match) {\n      return '\\\\' + escapes[match];\n    };\n  \n    // JavaScript micro-templating, similar to John Resig's implementation.\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\n    // and correctly escapes quotes within interpolated code.\n    // NB: `oldSettings` only exists for backwards compatibility.\n    _.template = function(text, settings, oldSettings) {\n      if (!settings && oldSettings) settings = oldSettings;\n      settings = _.defaults({}, settings, _.templateSettings);\n  \n      // Combine delimiters into one regular expression via alternation.\n      var matcher = RegExp([\n        (settings.escape || noMatch).source,\n        (settings.interpolate || noMatch).source,\n        (settings.evaluate || noMatch).source\n      ].join('|') + '|$', 'g');\n  \n      // Compile the template source, escaping string literals appropriately.\n      var index = 0;\n      var source = \"__p+='\";\n      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n        source += text.slice(index, offset).replace(escaper, escapeChar);\n        index = offset + match.length;\n  \n        if (escape) {\n          source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n        } else if (interpolate) {\n          source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n        } else if (evaluate) {\n          source += \"';\\n\" + evaluate + \"\\n__p+='\";\n        }\n  \n        // Adobe VMs need the match returned to produce the correct offest.\n        return match;\n      });\n      source += \"';\\n\";\n  \n      // If a variable is not specified, place data values in local scope.\n      if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n  \n      source = \"var __t,__p='',__j=Array.prototype.join,\" +\n        \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n        source + 'return __p;\\n';\n  \n      try {\n        var render = new Function(settings.variable || 'obj', '_', source);\n      } catch (e) {\n        e.source = source;\n        throw e;\n      }\n  \n      var template = function(data) {\n        return render.call(this, data, _);\n      };\n  \n      // Provide the compiled source as a convenience for precompilation.\n      var argument = settings.variable || 'obj';\n      template.source = 'function(' + argument + '){\\n' + source + '}';\n  \n      return template;\n    };\n  \n    // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n    _.chain = function(obj) {\n      var instance = _(obj);\n      instance._chain = true;\n      return instance;\n    };\n  \n    // OOP\n    // ---------------\n    // If Underscore is called as a function, it returns a wrapped object that\n    // can be used OO-style. This wrapper holds altered versions of all the\n    // underscore functions. Wrapped objects may be chained.\n  \n    // Helper function to continue chaining intermediate results.\n    var result = function(instance, obj) {\n      return instance._chain ? _(obj).chain() : obj;\n    };\n  \n    // Add your own custom functions to the Underscore object.\n    _.mixin = function(obj) {\n      _.each(_.functions(obj), function(name) {\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n          var args = [this._wrapped];\n          push.apply(args, arguments);\n          return result(this, func.apply(_, args));\n        };\n      });\n    };\n  \n    // Add all of the Underscore functions to the wrapper object.\n    _.mixin(_);\n  \n    // Add all mutator Array functions to the wrapper.\n    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n      var method = ArrayProto[name];\n      _.prototype[name] = function() {\n        var obj = this._wrapped;\n        method.apply(obj, arguments);\n        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n        return result(this, obj);\n      };\n    });\n  \n    // Add all accessor Array functions to the wrapper.\n    _.each(['concat', 'join', 'slice'], function(name) {\n      var method = ArrayProto[name];\n      _.prototype[name] = function() {\n        return result(this, method.apply(this._wrapped, arguments));\n      };\n    });\n  \n    // Extracts the result from a wrapped and chained object.\n    _.prototype.value = function() {\n      return this._wrapped;\n    };\n  \n    // Provide unwrapping proxy for some methods used in engine operations\n    // such as arithmetic and JSON stringification.\n    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n  \n    _.prototype.toString = function() {\n      return '' + this._wrapped;\n    };\n  \n    // AMD registration happens at the end for compatibility with AMD loaders\n    // that may not enforce next-turn semantics on modules. Even though general\n    // practice for AMD registration is to be anonymous, underscore registers\n    // as a named module because, like jQuery, it is a base library that is\n    // popular enough to be bundled in a third party lib, but not be part of\n    // an AMD load request. Those cases could generate an error when an\n    // anonymous define() is called outside of a loader request.\n    if (typeof define === 'function' && define.amd) {\n      define('underscore', [], function() {\n        return _;\n      });\n    }\n  }.call(this));\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    /**\n     * Contains all Parse API classes and functions.\n     * @name Parse\n     * @namespace\n     *\n     * Contains all Parse API classes and functions.\n     */\n    var Parse = root.Parse\n  \n    var req = typeof (require) === 'function' ? require : null\n    // Load references to other dependencies\n    if (typeof (XMLHttpRequest) !== 'undefined') {\n      Parse.XMLHttpRequest = XMLHttpRequest\n    } else if (req && typeof (require.ensure) === 'undefined') {\n      Parse.XMLHttpRequest = req('xmlhttprequest').XMLHttpRequest\n    }\n    // Import Parse's local copy of underscore.\n    if (typeof (exports) !== 'undefined' && exports._) {\n      // We're running in a CommonJS environment\n      Parse._ = exports._.noConflict()\n      exports.Parse = Parse\n    } else {\n      Parse._ = _.noConflict()\n    }\n  \n    // If jQuery or Zepto has been included, grab a reference to it.\n    if (typeof ($) !== 'undefined') {\n      Parse.$ = $\n    }\n  \n    // Helpers\n    // -------\n  \n    // Shared empty constructor function to aid in prototype-chain creation.\n    var EmptyConstructor = function () {}\n  \n    // Helper function to correctly set up the prototype chain, for subclasses.\n    // Similar to `goog.inherits`, but uses a hash of prototype properties and\n    // class properties to be extended.\n    var inherits = function (parent, protoProps, staticProps) {\n      var child\n  \n      // The constructor function for the new subclass is either defined by you\n      // (the \"constructor\" property in your `extend` definition), or defaulted\n      // by us to simply call the parent's constructor.\n      if (protoProps && protoProps.hasOwnProperty('constructor')) {\n        child = protoProps.constructor\n      } else {\n        /** @ignore */\n        child = function () {\n          parent.apply(this, arguments)\n        }\n      }\n  \n      // Inherit class (static) properties from parent.\n      Parse._.extend(child, parent)\n  \n      // Set the prototype chain to inherit from `parent`, without calling\n      // `parent`'s constructor function.\n      EmptyConstructor.prototype = parent.prototype\n      child.prototype = new EmptyConstructor()\n  \n      // Add prototype properties (instance properties) to the subclass,\n      // if supplied.\n      if (protoProps) {\n        Parse._.extend(child.prototype, protoProps)\n      }\n  \n      // Add static properties to the constructor function, if supplied.\n      if (staticProps) {\n        Parse._.extend(child, staticProps)\n      }\n  \n      // Correctly set child's `prototype.constructor`.\n      child.prototype.constructor = child\n  \n      // Set a convenience property in case the parent's prototype is\n      // needed later.\n      child.__super__ = parent.prototype\n  \n      return child\n    }\n  \n    // Set the server for Parse to talk to.\n    Parse.serverURL = 'https://api.parse.com'\n  \n    // Check whether we are running in Node.js.\n    if (typeof (process) !== 'undefined' &&\n      process.versions &&\n      process.versions.node) {\n      Parse._isNode = true\n    }\n  \n    /**\n     * Call this method first to set up your authentication tokens for Parse.\n     * You can get your keys from the Data Browser on parse.com.\n     * @param {String} applicationId Your Parse Application ID.\n     * @param {String} javaScriptKey Your Parse JavaScript Key.\n     * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\n     */\n    Parse.initialize = function (applicationId, javaScriptKey, masterKey) {\n      if (masterKey) {\n        throw new Error('Parse.initialize() was passed a Master Key, which is only allowed from within Node.js.')\n      }\n      Parse._initialize(applicationId, javaScriptKey)\n    }\n  \n    /**\n     * Call this method first to set up master authentication tokens for Parse.\n     * This method is for Parse's own private use.\n     * @param {String} applicationId Your Parse Application ID.\n     * @param {String} javaScriptKey Your Parse JavaScript Key.\n     * @param {String} masterKey Your Parse Master Key.\n     */\n    Parse._initialize = function (applicationId, javaScriptKey, masterKey) {\n      Parse.applicationId = applicationId\n      Parse.javaScriptKey = javaScriptKey\n      Parse.masterKey = masterKey\n      Parse._useMasterKey = false\n    }\n  \n    // If we're running in node.js, allow using the master key.\n    if (Parse._isNode) {\n      Parse.initialize = Parse._initialize\n  \n      Parse.Cloud = Parse.Cloud || {}\n      /**\n       * Switches the Parse SDK to using the Master key.  The Master key grants\n       * priveleged access to the data in Parse and can be used to bypass ACLs and\n       * other restrictions that are applied to the client SDKs.\n       * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\n       * </p>\n       */\n      Parse.Cloud.useMasterKey = function () {\n        Parse._useMasterKey = true\n      }\n    }\n  \n    /**\n     * Returns prefix for Storage keys used by this instance of Parse.\n     * @param {String} path The relative suffix to append to it.\n     *     null or undefined is treated as the empty string.\n     * @return {String} The full key name.\n     */\n    Parse._getParsePath = function (path) {\n      if (!Parse.applicationId) {\n        throw new Error('You need to call Parse.initialize before using Parse.')\n      }\n      if (!path) {\n        path = ''\n      }\n      if (!Parse._.isString(path)) {\n        throw new Error(\"Tried to get a Storage path that wasn't a String.\")\n      }\n      if (path[0] === '/') {\n        path = path.substring(1)\n      }\n      return 'Parse/' + Parse.applicationId + '/' + path\n    }\n  \n    /**\n     * Returns a Promise that is resolved with the unique string for this app on\n     * this machine.\n     * Gets reset when Storage is cleared.\n     */\n    Parse._installationId = null\n    Parse._getInstallationId = function () {\n      // See if it's cached in RAM.\n      if (Parse._installationId) {\n        return Parse.Promise.as(Parse._installationId)\n      }\n  \n      // Try to get it from Storage.\n      var path = Parse._getParsePath('installationId')\n      return (Parse.Storage.getItemAsync(path)\n        .then(function (value) {\n          Parse._installationId = value\n  \n          if (!Parse._installationId || Parse._installationId === '') {\n            // It wasn't in Storage, so create a new one.\n            var hexOctet = function () {\n              return (\n              Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1)\n              )\n            }\n            Parse._installationId = (\n              hexOctet() + hexOctet() + '-' +\n              hexOctet() + '-' +\n              hexOctet() + '-' +\n              hexOctet() + '-' +\n              hexOctet() + hexOctet() + hexOctet())\n            return Parse.Storage.setItemAsync(path, Parse._installationId)\n          }\n  \n          return Parse.Promise.as(Parse._installationId)\n        })\n      )\n    }\n  \n    Parse._parseDate = function (iso8601) {\n      var regexp = new RegExp(\n        '^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' + 'T' +\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' +\n        '(.([0-9]+))?' + 'Z$')\n      var match = regexp.exec(iso8601)\n      if (!match) {\n        return null\n      }\n  \n      var year = match[1] || 0\n      var month = (match[2] || 1) - 1\n      var day = match[3] || 0\n      var hour = match[4] || 0\n      var minute = match[5] || 0\n      var second = match[6] || 0\n      var milli = match[8] || 0\n  \n      return new Date(Date.UTC(year, month, day, hour, minute, second, milli))\n    }\n  \n    Parse._ajaxIE8 = function (method, url, data) {\n      var promise = new Parse.Promise()\n      var xdr = new XDomainRequest()\n      xdr.onload = function () {\n        var response\n        try {\n          response = JSON.parse(xdr.responseText)\n        } catch (e) {\n          promise.reject(e)\n        }\n        if (response) {\n          promise.resolve(response)\n        }\n      }\n      xdr.onerror = xdr.ontimeout = function () {\n        // Let's fake a real error message.\n        var fakeResponse = {\n          responseText: JSON.stringify({\n            code: Parse.Error.X_DOMAIN_REQUEST,\n            error: \"IE's XDomainRequest does not supply error info.\"\n          })\n        }\n        promise.reject(fakeResponse)\n      }\n      xdr.onprogress = function () {}\n      xdr.open(method, url)\n      xdr.send(data)\n      return promise\n    }\n  \n    Parse._useXDomainRequest = function () {\n      if (typeof (XDomainRequest) !== 'undefined') {\n        // We're in IE 8+.\n        if ('withCredentials' in new XMLHttpRequest()) {\n          // We're in IE 10+.\n          return false\n        }\n        return true\n      }\n      return false\n    }\n  \n    Parse._ajax = function (method, url, data, success, error) {\n      var options = {\n        success: success,\n        error: error\n      }\n  \n      if (Parse._useXDomainRequest()) {\n        return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options)\n      }\n  \n      var promise = new Parse.Promise()\n      var attempts = 0\n  \n      var dispatch = function () {\n        var handled = false\n        var xhr = new Parse.XMLHttpRequest()\n  \n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n            if (handled) {\n              return\n            }\n            handled = true\n  \n            if (xhr.status >= 200 && xhr.status < 300) {\n              var response\n              try {\n                response = JSON.parse(xhr.responseText)\n              } catch (e) {\n                promise.reject(e)\n              }\n              if (response) {\n                promise.resolve(response, xhr.status, xhr)\n              }\n            } else if (xhr.status >= 500) { // Retry on 5XX\n              if (++attempts < 5) {\n                // Exponentially-growing delay\n                var delay = Math.round(\n                  Math.random() * 125 * Math.pow(2, attempts)\n                )\n                setTimeout(dispatch, delay)\n              } else {\n                // After 5 retries, fail\n                promise.reject(xhr)\n              }\n            } else {\n              promise.reject(xhr)\n            }\n          }\n        }\n  \n        xhr.open(method, url, true)\n        xhr.setRequestHeader('Content-Type', 'text/plain') // avoid pre-flight.\n        if (Parse._isNode) {\n          // Add a special user agent just for request from node.js.\n          xhr.setRequestHeader('User-Agent',\n            'Parse/' + Parse.VERSION +\n            ' (NodeJS ' + process.versions.node + ')')\n        }\n        xhr.send(data)\n      }\n  \n      dispatch()\n      return promise._thenRunCallbacks(options)\n    }\n  \n    // A self-propagating extend function.\n    Parse._extend = function (protoProps, classProps) {\n      var child = inherits(this, protoProps, classProps)\n      child.extend = this.extend\n      return child\n    }\n  \n    /**\n     * Options:\n     *   route: is classes, users, login, etc.\n     *   objectId: null if there is no associated objectId.\n     *   method: the http method for the REST API.\n     *   dataObject: the payload as an object, or null if there is none.\n     *   useMasterKey: overrides whether to use the master key if set.\n     * @ignore\n     */\n    Parse._request = function (options) {\n      var route = options.route\n      var className = options.className\n      var objectId = options.objectId\n      var method = options.method\n      var useMasterKey = options.useMasterKey\n      var sessionToken = options.sessionToken\n      var dataObject = options.data\n  \n      if (!Parse.applicationId) {\n        throw new Error('You must specify your applicationId using Parse.initialize.')\n      }\n  \n      if (!Parse.javaScriptKey && !Parse.masterKey) {\n        throw new Error('You must specify a key using Parse.initialize.')\n      }\n  \n      if (route !== 'batch' &&\n        route !== 'classes' &&\n        route !== 'events' &&\n        route !== 'files' &&\n        route !== 'functions' &&\n        route !== 'login' &&\n        route !== 'logout' &&\n        route !== 'push' &&\n        route !== 'requestPasswordReset' &&\n        route !== 'rest_verify_analytics' &&\n        route !== 'users' &&\n        route !== 'jobs' &&\n        route !== 'config' &&\n        route !== 'sessions' &&\n        route !== 'upgradeToRevocableSession') {\n        throw new Error(\"Bad route: '\" + route + \"'.\")\n      }\n  \n      var url = Parse.serverURL\n      if (url.charAt(url.length - 1) !== '/') {\n        url += '/'\n      }\n      if (Parse.serverURL.indexOf('https://api.parse.com') === 0) {\n        url += '1/'\n      }\n      url += route\n      if (className) {\n        url += '/' + className\n      }\n      if (objectId) {\n        url += '/' + objectId\n      }\n  \n      dataObject = Parse._.clone(dataObject || {})\n      if (method !== 'POST') {\n        dataObject._method = method\n        method = 'POST'\n      }\n  \n      if (Parse._.isUndefined(useMasterKey)) {\n        useMasterKey = Parse._useMasterKey\n      }\n  \n      dataObject._ApplicationId = Parse.applicationId\n      if (!useMasterKey) {\n        dataObject._JavaScriptKey = Parse.javaScriptKey\n      } else if (!Parse.masterKey) {\n        throw new Error('Cannot use the Master Key, it has not been provided.')\n      } else {\n        dataObject._MasterKey = Parse.masterKey\n      }\n  \n      dataObject._ClientVersion = Parse.VERSION\n  \n      return Parse._getInstallationId().then(function (iid) {\n        dataObject._InstallationId = iid\n  \n        if (sessionToken) {\n          return Parse.Promise.as({ _sessionToken: sessionToken })\n        }\n        if (!Parse.User._canUseCurrentUser()) {\n          return Parse.Promise.as(null)\n        }\n  \n        return Parse.User._currentAsync()\n      }).then(function (currentUser) {\n        if (currentUser && currentUser._sessionToken) {\n          dataObject._SessionToken = currentUser._sessionToken\n        }\n  \n        if (Parse.User._isRevocableSessionEnabled) {\n          dataObject._RevocableSession = '1'\n        }\n  \n        var data = JSON.stringify(dataObject)\n  \n        return Parse._ajax(method, url, data)\n      }).then(null, function (response) {\n        // Transform the error into an instance of Parse.Error by trying to parse\n        // the error string as JSON.\n        var error\n        if (response && response.responseText) {\n          try {\n            var errorJSON = JSON.parse(response.responseText)\n            error = new Parse.Error(errorJSON.code, errorJSON.error)\n          } catch (e) {\n            // If we fail to parse the error text, that's okay.\n            error = new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              'Received an error with invalid JSON from Parse: ' +\n              response.responseText)\n          }\n        } else {\n          error = new Parse.Error(\n            Parse.Error.CONNECTION_FAILED,\n            'XMLHttpRequest failed: ' + JSON.stringify(response))\n        }\n        // By explicitly returning a rejected Promise, this will work with\n        // either jQuery or Promises/A semantics.\n        return Parse.Promise.error(error)\n      })\n    }\n  \n    // Helper function to get a value from a Backbone object as a property\n    // or as a function.\n    Parse._getValue = function (object, prop) {\n      if (!(object && object[prop])) {\n        return null\n      }\n      return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop]\n    }\n  \n    /**\n     * Converts a value in a Parse Object into the appropriate representation.\n     * This is the JS equivalent of Java's Parse.maybeReferenceAndEncode(Object)\n     * if seenObjects is falsey. Otherwise any Parse.Objects not in\n     * seenObjects will be fully embedded rather than encoded\n     * as a pointer.  This array will be used to prevent going into an infinite\n     * loop because we have circular references.  If seenObjects\n     * is set, then none of the Parse Objects that are serialized can be dirty.\n     */\n    Parse._encode = function (value, seenObjects, disallowObjects) {\n      var _ = Parse._\n      if (value instanceof Parse.Object) {\n        if (disallowObjects) {\n          throw new Error('Parse.Objects not allowed here')\n        }\n        if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\n          return value._toPointer()\n        }\n        if (!value.dirty()) {\n          seenObjects = seenObjects.concat(value)\n          return Parse._encode(value._toFullJSON(seenObjects),\n            seenObjects,\n            disallowObjects)\n        }\n        throw new Error('Tried to save an object with a pointer to a new, unsaved object.')\n      }\n      if (value instanceof Parse.ACL) {\n        return value.toJSON()\n      }\n      if (_.isDate(value)) {\n        if (isNaN(value)) {\n          throw new Error('Cannot encode invalid Date')\n        }\n        return { '__type': 'Date', 'iso': value.toJSON() }\n      }\n      if (value instanceof Parse.GeoPoint) {\n        return value.toJSON()\n      }\n      if (_.isArray(value)) {\n        return _.map(value, function (x) {\n          return Parse._encode(x, seenObjects, disallowObjects)\n        })\n      }\n      if (_.isRegExp(value)) {\n        return value.source\n      }\n      if (value instanceof Parse.Relation) {\n        return value.toJSON()\n      }\n      if (value instanceof Parse.Op) {\n        return value.toJSON()\n      }\n      if (value instanceof Parse.File) {\n        if (!value.url()) {\n          throw new Error('Tried to save an object containing an unsaved file.')\n        }\n        return {\n          __type: 'File',\n          name: value.name(),\n          url: value.url()\n        }\n      }\n      if (_.isObject(value)) {\n        var output = {}\n        Parse._objectEach(value, function (v, k) {\n          output[k] = Parse._encode(v, seenObjects, disallowObjects)\n        })\n        return output\n      }\n      return value\n    }\n  \n    /**\n     * The inverse function of Parse._encode.\n     * TODO: make decode not mutate value.\n     */\n    Parse._decode = function (key, value) {\n      var _ = Parse._\n      if (!_.isObject(value)) {\n        return value\n      }\n      if (_.isArray(value)) {\n        Parse._arrayEach(value, function (v, k) {\n          value[k] = Parse._decode(k, v)\n        })\n        return value\n      }\n      if (value instanceof Parse.Object) {\n        return value\n      }\n      if (value instanceof Parse.File) {\n        return value\n      }\n      if (value instanceof Parse.Op) {\n        return value\n      }\n      if (value.__op) {\n        return Parse.Op._decode(value)\n      }\n      if (value.__type === 'Pointer' && value.className) {\n        var pointer = Parse.Object._create(value.className)\n        pointer._finishFetch({ objectId: value.objectId }, false)\n        return pointer\n      }\n      if (value.__type === 'Object' && value.className) {\n        // It's an Object included in a query result.\n        var className = value.className\n        delete value.__type\n        delete value.className\n        var object = Parse.Object._create(className)\n        object._finishFetch(value, true)\n        return object\n      }\n      if (value.__type === 'Date') {\n        return Parse._parseDate(value.iso)\n      }\n      if (value.__type === 'GeoPoint') {\n        return new Parse.GeoPoint({\n          latitude: value.latitude,\n          longitude: value.longitude\n        })\n      }\n      if (key === 'ACL') {\n        if (value instanceof Parse.ACL) {\n          return value\n        }\n        return new Parse.ACL(value)\n      }\n      if (value.__type === 'Relation') {\n        var relation = new Parse.Relation(null, key)\n        relation.targetClassName = value.className\n        return relation\n      }\n      if (value.__type === 'File') {\n        var file = new Parse.File(value.name)\n        file._url = value.url\n        return file\n      }\n      Parse._objectEach(value, function (v, k) {\n        value[k] = Parse._decode(k, v)\n      })\n      return value\n    }\n  \n    Parse._arrayEach = Parse._.each\n  \n    /**\n     * Does a deep traversal of every item in object, calling func on every one.\n     * @param {Object} object The object or array to traverse deeply.\n     * @param {Function} func The function to call for every item. It will\n     *     be passed the item as an argument. If it returns a truthy value, that\n     *     value will replace the item in its parent container.\n     * @returns {} the result of calling func on the top-level object itself.\n     */\n    Parse._traverse = function (object, func, seen) {\n      if (object instanceof Parse.Object) {\n        seen = seen || []\n        if (Parse._.indexOf(seen, object) >= 0) {\n          // We've already visited this object in this call.\n          return\n        }\n        seen.push(object)\n        Parse._traverse(object.attributes, func, seen)\n        return func(object)\n      }\n      if (object instanceof Parse.Relation || object instanceof Parse.File) {\n        // Nothing needs to be done, but we don't want to recurse into the\n        // object's parent infinitely, so we catch this case.\n        return func(object)\n      }\n      if (Parse._.isArray(object)) {\n        Parse._.each(object, function (child, index) {\n          var newChild = Parse._traverse(child, func, seen)\n          if (newChild) {\n            object[index] = newChild\n          }\n        })\n        return func(object)\n      }\n      if (Parse._.isObject(object)) {\n        Parse._each(object, function (child, key) {\n          var newChild = Parse._traverse(child, func, seen)\n          if (newChild) {\n            object[key] = newChild\n          }\n        })\n        return func(object)\n      }\n      return func(object)\n    }\n  \n    /**\n     * This is like _.each, except:\n     * * it doesn't work for so-called array-like objects,\n     * * it does work for dictionaries with a \"length\" attribute.\n     */\n    Parse._objectEach = Parse._each = function (obj, callback) {\n      var _ = Parse._\n      if (_.isObject(obj)) {\n        _.each(_.keys(obj), function (key) {\n          callback(obj[key], key)\n        })\n      } else {\n        _.each(obj, callback)\n      }\n    }\n  \n    // Helper function to check null or undefined.\n    Parse._isNullOrUndefined = function (x) {\n      return Parse._.isNull(x) || Parse._.isUndefined(x)\n    }\n  }(this))\n  \n  /* global require: false, localStorage: false */\n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n  \n    var Storage = {\n      async: false\n    }\n  \n    var hasLocalStorage = (typeof localStorage !== 'undefined')\n    if (hasLocalStorage) {\n      try {\n        localStorage.setItem('supported', true)\n        localStorage.removeItem('supported')\n      } catch (e) {\n        hasLocalStorage = false\n      }\n    }\n    if (hasLocalStorage) {\n      Storage.getItem = function (path) {\n        return localStorage.getItem(path)\n      }\n  \n      Storage.setItem = function (path, value) {\n        return localStorage.setItem(path, value)\n      }\n  \n      Storage.removeItem = function (path) {\n        return localStorage.removeItem(path)\n      }\n  \n      Storage.clear = function () {\n        return localStorage.clear()\n      }\n    } else if (typeof require === 'function' && typeof (require.ensure) === 'undefined') {\n      var AsyncStorage\n      try {\n        AsyncStorage = require('AsyncStorage')\n  \n        Storage.async = true\n  \n        Storage.getItemAsync = function (path) {\n          var p = new Parse.Promise()\n          AsyncStorage.getItem(path, function (err, value) {\n            if (err) {\n              p.reject(err)\n            } else {\n              p.resolve(value)\n            }\n          })\n          return p\n        }\n  \n        Storage.setItemAsync = function (path, value) {\n          var p = new Parse.Promise()\n          AsyncStorage.setItem(path, value, function (err) {\n            if (err) {\n              p.reject(err)\n            } else {\n              p.resolve(value)\n            }\n          })\n          return p\n        }\n  \n        Storage.removeItemAsync = function (path) {\n          var p = new Parse.Promise()\n          AsyncStorage.removeItem(path, function (err) {\n            if (err) {\n              p.reject(err)\n            } else {\n              p.resolve()\n            }\n          })\n          return p\n        }\n  \n        Storage.clear = function () {\n          AsyncStorage.clear()\n        }\n      } catch (e) {}\n    }\n    if (!Storage.async && !Storage.getItem) {\n      var memMap = Storage.inMemoryMap = {}\n      Storage.getItem = function (path) {\n        if (memMap.hasOwnProperty(path)) {\n          return memMap[path]\n        }\n        return null\n      }\n  \n      Storage.setItem = function (path, value) {\n        memMap[path] = String(value)\n      }\n  \n      Storage.removeItem = function (path) {\n        delete memMap[path]\n      }\n  \n      Storage.clear = function () {\n        for (var key in memMap) {\n          if (memMap.hasOwnProperty(key)) {\n            delete memMap[key]\n          }\n        }\n      }\n    }\n  \n    // We can use synchronous methods from async scenarios, but not vice-versa\n    if (!Storage.async) {\n      Storage.getItemAsync = function (path) {\n        return Parse.Promise.as(\n          Storage.getItem(path)\n        )\n      }\n  \n      Storage.setItemAsync = function (path, value) {\n        Storage.setItem(path, value)\n        return Parse.Promise.as(value)\n      }\n  \n      Storage.removeItemAsync = function (path) {\n        return Parse.Promise.as(\n          Storage.removeItem(path)\n        )\n      }\n    }\n  \n    Parse.Storage = Storage\n  })(this)\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * @namespace Provides an interface to Parse's logging and analytics backend.\n     */\n    Parse.Analytics = Parse.Analytics || {}\n  \n    _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\n      /**\n       * Tracks the occurrence of a custom event with additional dimensions.\n       * Parse will store a data point at the time of invocation with the given\n       * event name.\n       *\n       * Dimensions will allow segmentation of the occurrences of this custom\n       * event. Keys and values should be {@code String}s, and will throw\n       * otherwise.\n       *\n       * To track a user signup along with additional metadata, consider the\n       * following:\n       * <pre>\n       * var dimensions = {\n       *  gender: 'm',\n       *  source: 'web',\n       *  dayType: 'weekend'\n       * }\n       * Parse.Analytics.track('signup', dimensions)\n       * </pre>\n       *\n       * There is a default limit of 8 dimensions per event tracked.\n       *\n       * @param {String} name The name of the custom event to report to Parse as\n       * having happened.\n       * @param {Object} dimensions The dictionary of information by which to\n       * segment this event.\n       * @param {Object} options A Backbone-style callback object.\n       * @return {Parse.Promise} A promise that is resolved when the round-trip\n       * to the server completes.\n       */\n      track: function (name, dimensions, options) {\n        name = name || ''\n        name = name.replace(/^\\s*/, '')\n        name = name.replace(/\\s*$/, '')\n        if (name.length === 0) {\n          throw new Error('A name for the custom event must be provided')\n        }\n  \n        _.each(dimensions, function (val, key) {\n          if (!_.isString(key) || !_.isString(val)) {\n            throw new Error('track() dimensions expects keys and values of type \"string\".')\n          }\n        })\n  \n        options = options || {}\n        return Parse._request({\n          route: 'events',\n          className: name,\n          method: 'POST',\n          data: { dimensions: dimensions }\n        })._thenRunCallbacks(options)\n      }\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * @class Parse.Config is a local representation of configuration data that\n     * can be set from the Parse dashboard.\n     */\n    Parse.Config = function () {\n      this.attributes = {}\n      this._escapedAttributes = {}\n    }\n  \n    /**\n     * Retrieves the most recently-fetched configuration object, either from\n     * memory or from local storage if necessary.\n     *\n     * @return {Parse.Config} The most recently-fetched Parse.Config if it\n     *     exists, else an empty Parse.Config.\n     */\n    Parse.Config.current = function () {\n      if (Parse.Config._currentConfig) {\n        return Parse.Config._currentConfig\n      }\n  \n      var config = new Parse.Config()\n  \n      if (Parse.Storage.async) {\n        return config\n      }\n  \n      var configData = Parse.Storage.getItem(Parse._getParsePath(\n        Parse.Config._CURRENT_CONFIG_KEY))\n  \n      if (configData) {\n        config._finishFetch(JSON.parse(configData))\n        Parse.Config._currentConfig = config\n      }\n      return config\n    }\n  \n    /**\n     * Gets a new configuration object from the server.\n     * @param {Object} options A Backbone-style options object.\n     * Valid options are:<ul>\n     *   <li>success: Function to call when the get completes successfully.\n     *   <li>error: Function to call when the get fails.\n     * </ul>\n     * @return {Parse.Promise} A promise that is resolved with a newly-created\n     *     configuration object when the get completes.\n     */\n    Parse.Config.get = function (options) {\n      options = options || {}\n  \n      var request = Parse._request({\n        route: 'config',\n        method: 'GET'\n      })\n  \n      return request.then(function (response) {\n        if (!response || !response.params) {\n          var errorObject = new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'Config JSON response invalid.')\n          return Parse.Promise.error(errorObject)\n        }\n  \n        var config = new Parse.Config()\n        config._finishFetch(response)\n        Parse.Config._currentConfig = config\n        return config\n      })._thenRunCallbacks(options)\n    }\n  \n    Parse.Config.prototype = {\n  \n      /**\n       * Gets the HTML-escaped value of an attribute.\n       */\n      escape: function (attr) {\n        var html = this._escapedAttributes[attr]\n        if (html) {\n          return html\n        }\n        var val = this.attributes[attr]\n        var escaped\n        if (Parse._isNullOrUndefined(val)) {\n          escaped = ''\n        } else {\n          escaped = _.escape(val.toString())\n        }\n        this._escapedAttributes[attr] = escaped\n        return escaped\n      },\n  \n      /**\n       * Gets the value of an attribute.\n       * @param {String} attr The name of an attribute.\n       */\n      get: function (attr) {\n        return this.attributes[attr]\n      },\n  \n      _finishFetch: function (serverData) {\n        this.attributes = Parse._decode(null, _.clone(serverData.params))\n        if (!Parse.Storage.async) {\n          // We only provide local caching of config with synchronous Storage\n          Parse.Storage.setItem(\n            Parse._getParsePath(Parse.Config._CURRENT_CONFIG_KEY),\n            JSON.stringify(serverData))\n        }\n      }\n    }\n  \n    Parse.Config._currentConfig = null\n  \n    Parse.Config._CURRENT_CONFIG_KEY = 'currentConfig'\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Constructs a new Parse.Error object with the given code and message.\n     * @param {Number} code An error code constant from <code>Parse.Error</code>.\n     * @param {String} message A detailed description of the error.\n     * @class\n     *\n     * <p>Class used for all objects passed to error callbacks.</p>\n     */\n    Parse.Error = function (code, message) {\n      this.code = code\n      this.message = message\n    }\n  \n    _.extend(Parse.Error, /** @lends Parse.Error */ {\n      /**\n       * Error code indicating some error other than those enumerated here.\n       * @constant\n       */\n      OTHER_CAUSE: -1,\n  \n      /**\n       * Error code indicating that something has gone wrong with the server.\n       * If you get this error code, it is Parse's fault. Contact us at\n       * https://parse.com/help\n       * @constant\n       */\n      INTERNAL_SERVER_ERROR: 1,\n  \n      /**\n       * Error code indicating the connection to the Parse servers failed.\n       * @constant\n       */\n      CONNECTION_FAILED: 100,\n  \n      /**\n       * Error code indicating the specified object doesn't exist.\n       * @constant\n       */\n      OBJECT_NOT_FOUND: 101,\n  \n      /**\n       * Error code indicating you tried to query with a datatype that doesn't\n       * support it, like exact matching an array or object.\n       * @constant\n       */\n      INVALID_QUERY: 102,\n  \n      /**\n       * Error code indicating a missing or invalid classname. Classnames are\n       * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\n       * only valid characters.\n       * @constant\n       */\n      INVALID_CLASS_NAME: 103,\n  \n      /**\n       * Error code indicating an unspecified object id.\n       * @constant\n       */\n      MISSING_OBJECT_ID: 104,\n  \n      /**\n       * Error code indicating an invalid key name. Keys are case-sensitive. They\n       * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\n       * @constant\n       */\n      INVALID_KEY_NAME: 105,\n  \n      /**\n       * Error code indicating a malformed pointer. You should not see this unless\n       * you have been mucking about changing internal Parse code.\n       * @constant\n       */\n      INVALID_POINTER: 106,\n  \n      /**\n       * Error code indicating that badly formed JSON was received upstream. This\n       * either indicates you have done something unusual with modifying how\n       * things encode to JSON, or the network is failing badly.\n       * @constant\n       */\n      INVALID_JSON: 107,\n  \n      /**\n       * Error code indicating that the feature you tried to access is only\n       * available internally for testing purposes.\n       * @constant\n       */\n      COMMAND_UNAVAILABLE: 108,\n  \n      /**\n       * You must call Parse.initialize before using the Parse library.\n       * @constant\n       */\n      NOT_INITIALIZED: 109,\n  \n      /**\n       * Error code indicating that a field was set to an inconsistent type.\n       * @constant\n       */\n      INCORRECT_TYPE: 111,\n  \n      /**\n       * Error code indicating an invalid channel name. A channel name is either\n       * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\n       * characters and starts with a letter.\n       * @constant\n       */\n      INVALID_CHANNEL_NAME: 112,\n  \n      /**\n       * Error code indicating that push is misconfigured.\n       * @constant\n       */\n      PUSH_MISCONFIGURED: 115,\n  \n      /**\n       * Error code indicating that the object is too large.\n       * @constant\n       */\n      OBJECT_TOO_LARGE: 116,\n  \n      /**\n       * Error code indicating that the operation isn't allowed for clients.\n       * @constant\n       */\n      OPERATION_FORBIDDEN: 119,\n  \n      /**\n       * Error code indicating the result was not found in the cache.\n       * @constant\n       */\n      CACHE_MISS: 120,\n  \n      /**\n       * Error code indicating that an invalid key was used in a nested\n       * JSONObject.\n       * @constant\n       */\n      INVALID_NESTED_KEY: 121,\n  \n      /**\n       * Error code indicating that an invalid filename was used for ParseFile.\n       * A valid file name contains only a-zA-Z0-9_. characters and is between 1\n       * and 128 characters.\n       * @constant\n       */\n      INVALID_FILE_NAME: 122,\n  \n      /**\n       * Error code indicating an invalid ACL was provided.\n       * @constant\n       */\n      INVALID_ACL: 123,\n  \n      /**\n       * Error code indicating that the request timed out on the server. Typically\n       * this indicates that the request is too expensive to run.\n       * @constant\n       */\n      TIMEOUT: 124,\n  \n      /**\n       * Error code indicating that the email address was invalid.\n       * @constant\n       */\n      INVALID_EMAIL_ADDRESS: 125,\n  \n      /**\n       * Error code indicating a missing content type.\n       * @constant\n       */\n      MISSING_CONTENT_TYPE: 126,\n  \n      /**\n       * Error code indicating a missing content length.\n       * @constant\n       */\n      MISSING_CONTENT_LENGTH: 127,\n  \n      /**\n       * Error code indicating an invalid content length.\n       * @constant\n       */\n      INVALID_CONTENT_LENGTH: 128,\n  \n      /**\n       * Error code indicating a file that was too large.\n       * @constant\n       */\n      FILE_TOO_LARGE: 129,\n  \n      /**\n       * Error code indicating an error saving a file.\n       * @constant\n       */\n      FILE_SAVE_ERROR: 130,\n  \n      /**\n       * Error code indicating that a unique field was given a value that is\n       * already taken.\n       * @constant\n       */\n      DUPLICATE_VALUE: 137,\n  \n      /**\n       * Error code indicating that a role's name is invalid.\n       * @constant\n       */\n      INVALID_ROLE_NAME: 139,\n  \n      /**\n       * Error code indicating that an application quota was exceeded.  Upgrade to\n       * resolve.\n       * @constant\n       */\n      EXCEEDED_QUOTA: 140,\n  \n      /**\n       * Error code indicating that a Cloud Code script failed.\n       * @constant\n       */\n      SCRIPT_FAILED: 141,\n  \n      /**\n       * Error code indicating that a Cloud Code validation failed.\n       * @constant\n       */\n      VALIDATION_ERROR: 142,\n  \n      /**\n       * Error code indicating that invalid image data was provided.\n       * @constant\n       */\n      INVALID_IMAGE_DATA: 150,\n  \n      /**\n       * Error code indicating an unsaved file.\n       * @constant\n       */\n      UNSAVED_FILE_ERROR: 151,\n  \n      /**\n       * Error code indicating an invalid push time.\n       */\n      INVALID_PUSH_TIME_ERROR: 152,\n  \n      /**\n       * Error code indicating an error deleting a file.\n       * @constant\n       */\n      FILE_DELETE_ERROR: 153,\n  \n      /**\n       * Error code indicating that the application has exceeded its request\n       * limit.\n       * @constant\n       */\n      REQUEST_LIMIT_EXCEEDED: 155,\n  \n      /**\n       * Error code indicating an invalid event name.\n       */\n      INVALID_EVENT_NAME: 160,\n  \n      /**\n       * Error code indicating that the username is missing or empty.\n       * @constant\n       */\n      USERNAME_MISSING: 200,\n  \n      /**\n       * Error code indicating that the password is missing or empty.\n       * @constant\n       */\n      PASSWORD_MISSING: 201,\n  \n      /**\n       * Error code indicating that the username has already been taken.\n       * @constant\n       */\n      USERNAME_TAKEN: 202,\n  \n      /**\n       * Error code indicating that the email has already been taken.\n       * @constant\n       */\n      EMAIL_TAKEN: 203,\n  \n      /**\n       * Error code indicating that the email is missing, but must be specified.\n       * @constant\n       */\n      EMAIL_MISSING: 204,\n  \n      /**\n       * Error code indicating that a user with the specified email was not found.\n       * @constant\n       */\n      EMAIL_NOT_FOUND: 205,\n  \n      /**\n       * Error code indicating that a user object without a valid session could\n       * not be altered.\n       * @constant\n       */\n      SESSION_MISSING: 206,\n  \n      /**\n       * Error code indicating that a user can only be created through signup.\n       * @constant\n       */\n      MUST_CREATE_USER_THROUGH_SIGNUP: 207,\n  \n      /**\n       * Error code indicating that an an account being linked is already linked\n       * to another user.\n       * @constant\n       */\n      ACCOUNT_ALREADY_LINKED: 208,\n  \n      /**\n       * Error code indicating that the current session token is invalid.\n       * @constant\n       */\n      INVALID_SESSION_TOKEN: 209,\n  \n      /**\n       * Error code indicating that a user cannot be linked to an account because\n       * that account's id could not be found.\n       * @constant\n       */\n      LINKED_ID_MISSING: 250,\n  \n      /**\n       * Error code indicating that a user with a linked (e.g. Facebook) account\n       * has an invalid session.\n       * @constant\n       */\n      INVALID_LINKED_SESSION: 251,\n  \n      /**\n       * Error code indicating that a service being linked (e.g. Facebook or\n       * Twitter) is unsupported.\n       * @constant\n       */\n      UNSUPPORTED_SERVICE: 252,\n  \n      /**\n       * Error code indicating that there were multiple errors. Aggregate errors\n       * have an \"errors\" property, which is an array of error objects with more\n       * detail about each error that occurred.\n       * @constant\n       */\n      AGGREGATE_ERROR: 600,\n  \n      /**\n       * Error code indicating the client was unable to read an input file.\n       * @constant\n       */\n      FILE_READ_ERROR: 601,\n  \n      /**\n       * Error code indicating a real error code is unavailable because\n       * we had to use an XDomainRequest object to allow CORS requests in\n       * Internet Explorer, which strips the body from HTTP responses that have\n       * a non-2XX status code.\n       * @constant\n       */\n      X_DOMAIN_REQUEST: 602\n    })\n  }(this))\n  \n  ;(function () {\n    var root = this\n    var Parse = (root.Parse || (root.Parse = {}))\n    var eventSplitter = /\\s+/\n    var slice = Array.prototype.slice\n  \n    /**\n     * @class\n     *\n     * <p>Parse.Events is a fork of Backbone's Events module, provided for your\n     * convenience.</p>\n     *\n     * <p>A module that can be mixed in to any object in order to provide\n     * it with custom events. You may bind callback functions to an event\n     * with `on`, or remove these functions with `off`.\n     * Triggering an event fires all callbacks in the order that `on` was\n     * called.\n     *\n     * <pre>\n     *     var object = {}\n     *     _.extend(object, Parse.Events)\n     *     object.on('expand', function(){ alert('expanded'); })\n     *     object.trigger('expand');</pre></p>\n     *\n     * <p>For more information, see the\n     * <a href=\"http://documentcloud.github.com/backbone/#Events\">Backbone\n     * documentation</a>.</p>\n     */\n    Parse.Events = {\n      /**\n       * Bind one or more space separated events, `events`, to a `callback`\n       * function. Passing `\"all\"` will bind the callback to all events fired.\n       */\n      on: function (events, callback, context) {\n        var calls, event, node, tail, list\n        if (!callback) {\n          return this\n        }\n        events = events.split(eventSplitter)\n        calls = this._callbacks || (this._callbacks = {})\n  \n        // Create an immutable callback list, allowing traversal during\n        // modification.  The tail is an empty object that will always be used\n        // as the next node.\n        event = events.shift()\n        while (event) {\n          list = calls[event]\n          node = list ? list.tail : {}\n          node.next = tail = {}\n          node.context = context\n          node.callback = callback\n          calls[event] = {tail: tail, next: list ? list.next : node}\n          event = events.shift()\n        }\n  \n        return this\n      },\n  \n      /**\n       * Remove one or many callbacks. If `context` is null, removes all callbacks\n       * with that function. If `callback` is null, removes all callbacks for the\n       * event. If `events` is null, removes all bound callbacks for all events.\n       */\n      off: function (events, callback, context) {\n        var event, calls, node, tail, cb, ctx\n  \n        // No events, or removing *all* events.\n        if (!(calls = this._callbacks)) {\n          return\n        }\n        if (!(events || callback || context)) {\n          delete this._callbacks\n          return this\n        }\n  \n        // Loop through the listed events and contexts, splicing them out of the\n        // linked list of callbacks if appropriate.\n        events = events ? events.split(eventSplitter) : Object.keys(calls)\n        event = events.shift()\n        while (event) {\n          node = calls[event]\n          delete calls[event]\n          if (!node || !(callback || context)) {\n            event = events.shift()\n            continue\n          }\n          // Create a new list, omitting the indicated callbacks.\n          tail = node.tail\n          node = node.next\n          while (node !== tail) {\n            cb = node.callback\n            ctx = node.context\n            if ((callback && cb !== callback) || (context && ctx !== context)) {\n              this.on(event, cb, ctx)\n            }\n            node = node.next\n          }\n          event = events.shift()\n        }\n  \n        return this\n      },\n  \n      /**\n       * Trigger one or many events, firing all bound callbacks. Callbacks are\n       * passed the same arguments as `trigger` is, apart from the event name\n       * (unless you're listening on `\"all\"`, which will cause your callback to\n       * receive the true name of the event as the first argument).\n       */\n      trigger: function (events) {\n        var event, node, calls, tail, args, all, rest\n        if (!(calls = this._callbacks)) {\n          return this\n        }\n        all = calls.all\n        events = events.split(eventSplitter)\n        rest = slice.call(arguments, 1)\n  \n        // For each event, walk through the linked list of callbacks twice,\n        // first to trigger the event, then to trigger any `\"all\"` callbacks.\n        event = events.shift()\n        while (event) {\n          node = calls[event]\n          if (node) {\n            tail = node.tail\n            while ((node = node.next) !== tail) {\n              node.callback.apply(node.context || this, rest)\n            }\n          }\n          node = all\n          if (node) {\n            tail = node.tail\n            args = [event].concat(rest)\n            while ((node = node.next) !== tail) {\n              node.callback.apply(node.context || this, args)\n            }\n          }\n          event = events.shift()\n        }\n  \n        return this\n      }\n    }\n  \n    /**\n     * @function\n     */\n    Parse.Events.bind = Parse.Events.on\n  \n    /**\n     * @function\n     */\n    Parse.Events.unbind = Parse.Events.off\n  }.call(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creates a new GeoPoint with any of the following forms:<br>\n     *   <pre>\n     *   new GeoPoint(otherGeoPoint)\n     *   new GeoPoint(30, 30)\n     *   new GeoPoint([30, 30])\n     *   new GeoPoint({latitude: 30, longitude: 30})\n     *   new GeoPoint()  // defaults to (0, 0)\n     *   </pre>\n     * @class\n     *\n     * <p>Represents a latitude / longitude point that may be associated\n     * with a key in a ParseObject or used as a reference point for geo queries.\n     * This allows proximity-based queries on the key.</p>\n     *\n     * <p>Only one key in a class may contain a GeoPoint.</p>\n     *\n     * <p>Example:<pre>\n     *   var point = new Parse.GeoPoint(30.0, -20.0)\n     *   var object = new Parse.Object(\"PlaceObject\")\n     *   object.set(\"location\", point)\n     *   object.save();</pre></p>\n     */\n    Parse.GeoPoint = function (arg1, arg2) {\n      if (_.isArray(arg1)) {\n        Parse.GeoPoint._validate(arg1[0], arg1[1])\n        this.latitude = arg1[0]\n        this.longitude = arg1[1]\n      } else if (_.isObject(arg1)) {\n        Parse.GeoPoint._validate(arg1.latitude, arg1.longitude)\n        this.latitude = arg1.latitude\n        this.longitude = arg1.longitude\n      } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\n        Parse.GeoPoint._validate(arg1, arg2)\n        this.latitude = arg1\n        this.longitude = arg2\n      } else {\n        this.latitude = 0\n        this.longitude = 0\n      }\n  \n      // Add properties so that anyone using Webkit or Mozilla will get an error\n      // if they try to set values that are out of bounds.\n      var self = this\n      if (this.__defineGetter__ && this.__defineSetter__) {\n        // Use _latitude and _longitude to actually store the values, and add\n        // getters and setters for latitude and longitude.\n        this._latitude = this.latitude\n        this._longitude = this.longitude\n        this.__defineGetter__('latitude', function () {\n          return self._latitude\n        })\n        this.__defineGetter__('longitude', function () {\n          return self._longitude\n        })\n        this.__defineSetter__('latitude', function (val) {\n          Parse.GeoPoint._validate(val, self.longitude)\n          self._latitude = val\n        })\n        this.__defineSetter__('longitude', function (val) {\n          Parse.GeoPoint._validate(self.latitude, val)\n          self._longitude = val\n        })\n      }\n    }\n  \n    /**\n     * @lends Parse.GeoPoint.prototype\n     * @property {float} latitude North-south portion of the coordinate, in range\n     *   [-90, 90].  Throws an exception if set out of range in a modern browser.\n     * @property {float} longitude East-west portion of the coordinate, in range\n     *   [-180, 180].  Throws if set out of range in a modern browser.\n     */\n  \n    /**\n     * Throws an exception if the given lat-long is out of bounds.\n     */\n    Parse.GeoPoint._validate = function (latitude, longitude) {\n      if (latitude < -90.0) {\n        throw new Error('Parse.GeoPoint latitude ' + latitude + ' < -90.0.')\n      }\n      if (latitude > 90.0) {\n        throw new Error('Parse.GeoPoint latitude ' + latitude + ' > 90.0.')\n      }\n      if (longitude < -180.0) {\n        throw new Error('Parse.GeoPoint longitude ' + longitude + ' < -180.0.')\n      }\n      if (longitude > 180.0) {\n        throw new Error('Parse.GeoPoint longitude ' + longitude + ' > 180.0.')\n      }\n    }\n  \n    /**\n     * Creates a GeoPoint with the user's current location, if available.\n     * Calls options.success with a new GeoPoint instance or calls options.error.\n     * @param {Object} options An object with success and error callbacks.\n     */\n    Parse.GeoPoint.current = function (options) {\n      var promise = new Parse.Promise()\n      navigator.geolocation.getCurrentPosition(function (location) {\n        promise.resolve(new Parse.GeoPoint({\n          latitude: location.coords.latitude,\n          longitude: location.coords.longitude\n        }))\n      }, function (error) {\n        promise.reject(error)\n      })\n  \n      return promise._thenRunCallbacks(options)\n    }\n  \n    Parse.GeoPoint.prototype = {\n      /**\n       * Returns a JSON representation of the GeoPoint, suitable for Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        Parse.GeoPoint._validate(this.latitude, this.longitude)\n        return {\n          '__type': 'GeoPoint',\n          latitude: this.latitude,\n          longitude: this.longitude\n        }\n      },\n  \n      /**\n       * Returns the distance from this GeoPoint to another in radians.\n       * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n       * @return {Number}\n       */\n      radiansTo: function (point) {\n        var d2r = Math.PI / 180.0\n        var lat1rad = this.latitude * d2r\n        var long1rad = this.longitude * d2r\n        var lat2rad = point.latitude * d2r\n        var long2rad = point.longitude * d2r\n        var deltaLat = lat1rad - lat2rad\n        var deltaLong = long1rad - long2rad\n        var sinDeltaLatDiv2 = Math.sin(deltaLat / 2)\n        var sinDeltaLongDiv2 = Math.sin(deltaLong / 2)\n        // Square of half the straight line chord distance between both points.\n        var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\n          (Math.cos(lat1rad) * Math.cos(lat2rad) *\n          sinDeltaLongDiv2 * sinDeltaLongDiv2))\n        a = Math.min(1.0, a)\n        return 2 * Math.asin(Math.sqrt(a))\n      },\n  \n      /**\n       * Returns the distance from this GeoPoint to another in kilometers.\n       * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n       * @return {Number}\n       */\n      kilometersTo: function (point) {\n        return this.radiansTo(point) * 6371.0\n      },\n  \n      /**\n       * Returns the distance from this GeoPoint to another in miles.\n       * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n       * @return {Number}\n       */\n      milesTo: function (point) {\n        return this.radiansTo(point) * 3958.8\n      }\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    var PUBLIC_KEY = '*'\n  \n    /**\n     * Creates a new ACL.\n     * If no argument is given, the ACL has no permissions for anyone.\n     * If the argument is a Parse.User, the ACL will have read and write\n     *   permission for only that user.\n     * If the argument is any other JSON object, that object will be interpretted\n     *   as a serialized ACL created with toJSON().\n     * @see Parse.Object#setACL\n     * @class\n     *\n     * <p>An ACL, or Access Control List can be added to any\n     * <code>Parse.Object</code> to restrict access to only a subset of users\n     * of your application.</p>\n     */\n    Parse.ACL = function (arg1) {\n      var self = this\n      self.permissionsById = {}\n      if (_.isObject(arg1)) {\n        if (arg1 instanceof Parse.User) {\n          self.setReadAccess(arg1, true)\n          self.setWriteAccess(arg1, true)\n        } else {\n          if (_.isFunction(arg1)) {\n            throw new Error('Parse.ACL() called with a function.  Did you forget ()?')\n          }\n          Parse._objectEach(arg1, function (accessList, userId) {\n            if (!_.isString(userId)) {\n              throw new Error('Tried to create an ACL with an invalid userId.')\n            }\n            self.permissionsById[userId] = {}\n            Parse._objectEach(accessList, function (allowed, permission) {\n              if (permission !== 'read' && permission !== 'write') {\n                throw new Error('Tried to create an ACL with an invalid permission type.')\n              }\n              if (!_.isBoolean(allowed)) {\n                throw new Error('Tried to create an ACL with an invalid permission value.')\n              }\n              self.permissionsById[userId][permission] = allowed\n            })\n          })\n        }\n      }\n    }\n  \n    /**\n     * Returns a JSON-encoded version of the ACL.\n     * @return {Object}\n     */\n    Parse.ACL.prototype.toJSON = function () {\n      return _.clone(this.permissionsById)\n    }\n  \n    Parse.ACL.prototype._setAccess = function (accessType, userId, allowed) {\n      if (userId instanceof Parse.User) {\n        userId = userId.id\n      } else if (userId instanceof Parse.Role) {\n        userId = 'role:' + userId.getName()\n      }\n      if (!_.isString(userId)) {\n        throw new Error('userId must be a string.')\n      }\n      if (!_.isBoolean(allowed)) {\n        throw new Error('allowed must be either true or false.')\n      }\n      var permissions = this.permissionsById[userId]\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action needed.\n          return\n        } else {\n          permissions = {}\n          this.permissionsById[userId] = permissions\n        }\n      }\n  \n      if (allowed) {\n        this.permissionsById[userId][accessType] = true\n      } else {\n        delete permissions[accessType]\n        if (_.isEmpty(permissions)) {\n          delete permissions[userId]\n        }\n      }\n    }\n  \n    Parse.ACL.prototype._getAccess = function (accessType, userId) {\n      if (userId instanceof Parse.User) {\n        userId = userId.id\n      } else if (userId instanceof Parse.Role) {\n        userId = 'role:' + userId.getName()\n      }\n      var permissions = this.permissionsById[userId]\n      if (!permissions) {\n        return false\n      }\n      return !!(permissions[accessType])\n    }\n  \n    /**\n     * Set whether the given user is allowed to read this object.\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {Boolean} allowed Whether that user should have read access.\n     */\n    Parse.ACL.prototype.setReadAccess = function (userId, allowed) {\n      this._setAccess('read', userId, allowed)\n    }\n  \n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @return {Boolean}\n     */\n    Parse.ACL.prototype.getReadAccess = function (userId) {\n      return this._getAccess('read', userId)\n    }\n  \n    /**\n     * Set whether the given user id is allowed to write this object.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {Boolean} allowed Whether that user should have write access.\n     */\n    Parse.ACL.prototype.setWriteAccess = function (userId, allowed) {\n      this._setAccess('write', userId, allowed)\n    }\n  \n    /**\n     * Get whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @return {Boolean}\n     */\n    Parse.ACL.prototype.getWriteAccess = function (userId) {\n      return this._getAccess('write', userId)\n    }\n  \n    /**\n     * Set whether the public is allowed to read this object.\n     * @param {Boolean} allowed\n     */\n    Parse.ACL.prototype.setPublicReadAccess = function (allowed) {\n      this.setReadAccess(PUBLIC_KEY, allowed)\n    }\n  \n    /**\n     * Get whether the public is allowed to read this object.\n     * @return {Boolean}\n     */\n    Parse.ACL.prototype.getPublicReadAccess = function () {\n      return this.getReadAccess(PUBLIC_KEY)\n    }\n  \n    /**\n     * Set whether the public is allowed to write this object.\n     * @param {Boolean} allowed\n     */\n    Parse.ACL.prototype.setPublicWriteAccess = function (allowed) {\n      this.setWriteAccess(PUBLIC_KEY, allowed)\n    }\n  \n    /**\n     * Get whether the public is allowed to write this object.\n     * @return {Boolean}\n     */\n    Parse.ACL.prototype.getPublicWriteAccess = function () {\n      return this.getWriteAccess(PUBLIC_KEY)\n    }\n  \n    /**\n     * Get whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @return {Boolean} true if the role has read access. false otherwise.\n     * @throws {String} If role is neither a Parse.Role nor a String.\n     */\n    Parse.ACL.prototype.getRoleReadAccess = function (role) {\n      if (role instanceof Parse.Role) {\n        // Normalize to the String name\n        role = role.getName()\n      }\n      if (_.isString(role)) {\n        return this.getReadAccess('role:' + role)\n      }\n      throw new Error('role must be a Parse.Role or a String')\n    }\n  \n    /**\n     * Get whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @return {Boolean} true if the role has write access. false otherwise.\n     * @throws {String} If role is neither a Parse.Role nor a String.\n     */\n    Parse.ACL.prototype.getRoleWriteAccess = function (role) {\n      if (role instanceof Parse.Role) {\n        // Normalize to the String name\n        role = role.getName()\n      }\n      if (_.isString(role)) {\n        return this.getWriteAccess('role:' + role)\n      }\n      throw new Error('role must be a Parse.Role or a String')\n    }\n  \n    /**\n     * Set whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {Boolean} allowed Whether the given role can read this object.\n     * @throws {String} If role is neither a Parse.Role nor a String.\n     */\n    Parse.ACL.prototype.setRoleReadAccess = function (role, allowed) {\n      if (role instanceof Parse.Role) {\n        // Normalize to the String name\n        role = role.getName()\n      }\n      if (_.isString(role)) {\n        this.setReadAccess('role:' + role, allowed)\n        return\n      }\n      throw new Error('role must be a Parse.Role or a String')\n    }\n  \n    /**\n     * Set whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {Boolean} allowed Whether the given role can write this object.\n     * @throws {String} If role is neither a Parse.Role nor a String.\n     */\n    Parse.ACL.prototype.setRoleWriteAccess = function (role, allowed) {\n      if (role instanceof Parse.Role) {\n        // Normalize to the String name\n        role = role.getName()\n      }\n      if (_.isString(role)) {\n        this.setWriteAccess('role:' + role, allowed)\n        return\n      }\n      throw new Error('role must be a Parse.Role or a String')\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * @class\n     * A Parse.Op is an atomic operation that can be applied to a field in a\n     * Parse.Object. For example, calling <code>object.set(\"foo\", \"bar\")</code>\n     * is an example of a Parse.Op.Set. Calling <code>object.unset(\"foo\")</code>\n     * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\n     * sent to the server as part of <code>object.save()</code> operations.\n     * Instances of Parse.Op should be immutable.\n     *\n     * You should not create subclasses of Parse.Op or instantiate Parse.Op\n     * directly.\n     */\n    Parse.Op = function () {\n      this._initialize.apply(this, arguments)\n    }\n  \n    Parse.Op.prototype = {\n      _initialize: function () {}\n    }\n  \n    _.extend(Parse.Op, {\n      /**\n       * To create a new Op, call Parse.Op._extend()\n       */\n      _extend: Parse._extend,\n  \n      // A map of __op string to decoder function.\n      _opDecoderMap: {},\n  \n      /**\n       * Registers a function to convert a json object with an __op field into an\n       * instance of a subclass of Parse.Op.\n       */\n      _registerDecoder: function (opName, decoder) {\n        Parse.Op._opDecoderMap[opName] = decoder\n      },\n  \n      /**\n       * Converts a json object into an instance of a subclass of Parse.Op.\n       */\n      _decode: function (json) {\n        var decoder = Parse.Op._opDecoderMap[json.__op]\n        if (decoder) {\n          return decoder(json)\n        } else {\n          return undefined\n        }\n      }\n    })\n  \n    /*\n     * Add a handler for Batch ops.\n     */\n    Parse.Op._registerDecoder('Batch', function (json) {\n      var op = null\n      Parse._arrayEach(json.ops, function (nextOp) {\n        nextOp = Parse.Op._decode(nextOp)\n        op = nextOp._mergeWithPrevious(op)\n      })\n      return op\n    })\n  \n    /**\n     * @class\n     * A Set operation indicates that either the field was changed using\n     * Parse.Object.set, or it is a mutable container that was detected as being\n     * changed.\n     */\n    Parse.Op.Set = Parse.Op._extend({\n      _initialize: function (value) {\n        this._value = value\n      },\n  \n      /**\n       * Returns the new value of this field after the set.\n       */\n      value: function () {\n        return this._value\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return Parse._encode(this.value())\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        return this\n      },\n  \n      _estimate: function (oldValue) {\n        return this.value()\n      }\n    })\n  \n    /**\n     * A sentinel value that is returned by Parse.Op.Unset._estimate to\n     * indicate the field should be deleted. Basically, if you find _UNSET as a\n     * value in your object, you should remove that key.\n     */\n    Parse.Op._UNSET = {}\n  \n    /**\n     * @class\n     * An Unset operation indicates that this field has been deleted from the\n     * object.\n     */\n    Parse.Op.Unset = Parse.Op._extend({\n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { __op: 'Delete' }\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        return this\n      },\n  \n      _estimate: function (oldValue) {\n        return Parse.Op._UNSET\n      }\n    })\n  \n    Parse.Op._registerDecoder('Delete', function (json) {\n      return new Parse.Op.Unset()\n    })\n  \n    /**\n     * @class\n     * An Increment is an atomic operation where the numeric value for the field\n     * will be increased by a given amount.\n     */\n    Parse.Op.Increment = Parse.Op._extend({\n      _initialize: function (amount) {\n        this._amount = amount\n      },\n  \n      /**\n       * Returns the amount to increment by.\n       * @return {Number} the amount to increment by.\n       */\n      amount: function () {\n        return this._amount\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { __op: 'Increment', amount: this._amount }\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        if (!previous) {\n          return this\n        } else if (previous instanceof Parse.Op.Unset) {\n          return new Parse.Op.Set(this.amount())\n        } else if (previous instanceof Parse.Op.Set) {\n          return new Parse.Op.Set(previous.value() + this.amount())\n        } else if (previous instanceof Parse.Op.Increment) {\n          return new Parse.Op.Increment(this.amount() + previous.amount())\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      },\n  \n      _estimate: function (oldValue) {\n        if (!oldValue) {\n          return this.amount()\n        }\n        return oldValue + this.amount()\n      }\n    })\n  \n    Parse.Op._registerDecoder('Increment', function (json) {\n      return new Parse.Op.Increment(json.amount)\n    })\n  \n    /**\n     * @class\n     * Add is an atomic operation where the given objects will be appended to the\n     * array that is stored in this field.\n     */\n    Parse.Op.Add = Parse.Op._extend({\n      _initialize: function (objects) {\n        this._objects = objects\n      },\n  \n      /**\n       * Returns the objects to be added to the array.\n       * @return {Array} The objects to be added to the array.\n       */\n      objects: function () {\n        return this._objects\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { __op: 'Add', objects: Parse._encode(this.objects()) }\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        if (!previous) {\n          return this\n        } else if (previous instanceof Parse.Op.Unset) {\n          return new Parse.Op.Set(this.objects())\n        } else if (previous instanceof Parse.Op.Set) {\n          return new Parse.Op.Set(this._estimate(previous.value()))\n        } else if (previous instanceof Parse.Op.Add) {\n          return new Parse.Op.Add(previous.objects().concat(this.objects()))\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      },\n  \n      _estimate: function (oldValue) {\n        if (!oldValue) {\n          return _.clone(this.objects())\n        } else {\n          return oldValue.concat(this.objects())\n        }\n      }\n    })\n  \n    Parse.Op._registerDecoder('Add', function (json) {\n      return new Parse.Op.Add(Parse._decode(undefined, json.objects))\n    })\n  \n    /**\n     * @class\n     * AddUnique is an atomic operation where the given items will be appended to\n     * the array that is stored in this field only if they were not already\n     * present in the array.\n     */\n    Parse.Op.AddUnique = Parse.Op._extend({\n      _initialize: function (objects) {\n        this._objects = _.uniq(objects)\n      },\n  \n      /**\n       * Returns the objects to be added to the array.\n       * @return {Array} The objects to be added to the array.\n       */\n      objects: function () {\n        return this._objects\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { __op: 'AddUnique', objects: Parse._encode(this.objects()) }\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        if (!previous) {\n          return this\n        } else if (previous instanceof Parse.Op.Unset) {\n          return new Parse.Op.Set(this.objects())\n        } else if (previous instanceof Parse.Op.Set) {\n          return new Parse.Op.Set(this._estimate(previous.value()))\n        } else if (previous instanceof Parse.Op.AddUnique) {\n          return new Parse.Op.AddUnique(this._estimate(previous.objects()))\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      },\n  \n      _estimate: function (oldValue) {\n        if (!oldValue) {\n          return _.clone(this.objects())\n        } else {\n          // We can't just take the _.uniq(_.union(...)) of oldValue and\n          // this.objects, because the uniqueness may not apply to oldValue\n          // (especially if the oldValue was set via .set())\n          var newValue = _.clone(oldValue)\n          Parse._arrayEach(this.objects(), function (obj) {\n            if (obj instanceof Parse.Object && obj.id) {\n              var matchingObj = _.find(newValue, function (anObj) {\n                return (anObj instanceof Parse.Object) && (anObj.id === obj.id)\n              })\n              if (!matchingObj) {\n                newValue.push(obj)\n              } else {\n                var index = _.indexOf(newValue, matchingObj)\n                newValue[index] = obj\n              }\n            } else if (!_.contains(newValue, obj)) {\n              newValue.push(obj)\n            }\n          })\n          return newValue\n        }\n      }\n    })\n  \n    Parse.Op._registerDecoder('AddUnique', function (json) {\n      return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects))\n    })\n  \n    /**\n     * @class\n     * Remove is an atomic operation where the given objects will be removed from\n     * the array that is stored in this field.\n     */\n    Parse.Op.Remove = Parse.Op._extend({\n      _initialize: function (objects) {\n        this._objects = _.uniq(objects)\n      },\n  \n      /**\n       * Returns the objects to be removed from the array.\n       * @return {Array} The objects to be removed from the array.\n       */\n      objects: function () {\n        return this._objects\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { __op: 'Remove', objects: Parse._encode(this.objects()) }\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        if (!previous) {\n          return this\n        } else if (previous instanceof Parse.Op.Unset) {\n          return previous\n        } else if (previous instanceof Parse.Op.Set) {\n          return new Parse.Op.Set(this._estimate(previous.value()))\n        } else if (previous instanceof Parse.Op.Remove) {\n          return new Parse.Op.Remove(_.union(previous.objects(), this.objects()))\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      },\n  \n      _estimate: function (oldValue) {\n        if (!oldValue) {\n          return []\n        } else {\n          var newValue = _.difference(oldValue, this.objects())\n          // If there are saved Parse Objects being removed, also remove them.\n          Parse._arrayEach(this.objects(), function (obj) {\n            if (obj instanceof Parse.Object && obj.id) {\n              newValue = _.reject(newValue, function (other) {\n                return (other instanceof Parse.Object) && (other.id === obj.id)\n              })\n            }\n          })\n          return newValue\n        }\n      }\n    })\n  \n    Parse.Op._registerDecoder('Remove', function (json) {\n      return new Parse.Op.Remove(Parse._decode(undefined, json.objects))\n    })\n  \n    /**\n     * @class\n     * A Relation operation indicates that the field is an instance of\n     * Parse.Relation, and objects are being added to, or removed from, that\n     * relation.\n     */\n    Parse.Op.Relation = Parse.Op._extend({\n      _initialize: function (adds, removes) {\n        this._targetClassName = null\n  \n        var self = this\n  \n        var pointerToId = function (object) {\n          if (object instanceof Parse.Object) {\n            if (!object.id) {\n              throw new Error(\"You can't add an unsaved Parse.Object to a relation.\")\n            }\n            if (!self._targetClassName) {\n              self._targetClassName = object.className\n            }\n            if (self._targetClassName !== object.className) {\n              throw new Error('Tried to create a Parse.Relation with 2 different types: ' + self._targetClassName + ' and ' + object.className + '.')\n            }\n            return object.id\n          }\n          return object\n        }\n  \n        this.relationsToAdd = _.uniq(_.map(adds, pointerToId))\n        this.relationsToRemove = _.uniq(_.map(removes, pointerToId))\n      },\n  \n      /**\n       * Returns an array of unfetched Parse.Object that are being added to the\n       * relation.\n       * @return {Array}\n       */\n      added: function () {\n        var self = this\n        return _.map(this.relationsToAdd, function (objectId) {\n          var object = Parse.Object._create(self._targetClassName)\n          object.id = objectId\n          return object\n        })\n      },\n  \n      /**\n       * Returns an array of unfetched Parse.Object that are being removed from\n       * the relation.\n       * @return {Array}\n       */\n      removed: function () {\n        var self = this\n        return _.map(this.relationsToRemove, function (objectId) {\n          var object = Parse.Object._create(self._targetClassName)\n          object.id = objectId\n          return object\n        })\n      },\n  \n      /**\n       * Returns a JSON version of the operation suitable for sending to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        var adds = null\n        var removes = null\n        var self = this\n        var idToPointer = function (id) {\n          return { __type: 'Pointer',\n            className: self._targetClassName,\n          objectId: id }\n        }\n        var pointers = null\n        if (this.relationsToAdd.length > 0) {\n          pointers = _.map(this.relationsToAdd, idToPointer)\n          adds = { '__op': 'AddRelation', 'objects': pointers }\n        }\n  \n        if (this.relationsToRemove.length > 0) {\n          pointers = _.map(this.relationsToRemove, idToPointer)\n          removes = { '__op': 'RemoveRelation', 'objects': pointers }\n        }\n  \n        if (adds && removes) {\n          return {\n            __op: 'Batch',\n            ops: [\n              adds,\n              removes\n            ]\n          }\n        }\n  \n        return adds || removes || {}\n      },\n  \n      _mergeWithPrevious: function (previous) {\n        if (!previous) {\n          return this\n        } else if (previous instanceof Parse.Op.Unset) {\n          throw new Error(\"You can't modify a relation after deleting it.\")\n        } else if (previous instanceof Parse.Op.Relation) {\n          if (previous._targetClassName &&\n            previous._targetClassName !== this._targetClassName) {\n            throw new Error('Related object must be of class ' + previous._targetClassName + ', but ' + this._targetClassName + ' was passed in.')\n          }\n          var newAdd = _.union(_.difference(previous.relationsToAdd,\n            this.relationsToRemove),\n            this.relationsToAdd)\n          var newRemove = _.union(_.difference(previous.relationsToRemove,\n            this.relationsToAdd),\n            this.relationsToRemove)\n  \n          var newRelation = new Parse.Op.Relation(newAdd, newRemove)\n          newRelation._targetClassName = this._targetClassName\n          return newRelation\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      },\n  \n      _estimate: function (oldValue, object, key) {\n        if (!oldValue) {\n          var relation = new Parse.Relation(object, key)\n          relation.targetClassName = this._targetClassName\n        } else if (oldValue instanceof Parse.Relation) {\n          if (this._targetClassName) {\n            if (oldValue.targetClassName) {\n              if (oldValue.targetClassName !== this._targetClassName) {\n                throw new Error('Related object must be a ' + oldValue.targetClassName + ', but a ' + this._targetClassName + ' was passed in.')\n              }\n            } else {\n              oldValue.targetClassName = this._targetClassName\n            }\n          }\n          return oldValue\n        } else {\n          throw new Error('Op is invalid after previous op.')\n        }\n      }\n    })\n  \n    Parse.Op._registerDecoder('AddRelation', function (json) {\n      return new Parse.Op.Relation(Parse._decode(undefined, json.objects), [])\n    })\n    Parse.Op._registerDecoder('RemoveRelation', function (json) {\n      return new Parse.Op.Relation([], Parse._decode(undefined, json.objects))\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creates a new Relation for the given parent object and key. This\n     * constructor should rarely be used directly, but rather created by\n     * Parse.Object.relation.\n     * @param {Parse.Object} parent The parent of this relation.\n     * @param {String} key The key for this relation on the parent.\n     * @see Parse.Object#relation\n     * @class\n     *\n     * <p>\n     * A class that is used to access all of the children of a many-to-many\n     * relationship.  Each instance of Parse.Relation is associated with a\n     * particular parent object and key.\n     * </p>\n     */\n    Parse.Relation = function (parent, key) {\n      this.parent = parent\n      this.key = key\n      this.targetClassName = null\n    }\n  \n    Parse.Relation.prototype = {\n      /**\n       * Makes sure that this relation has the right parent and key.\n       */\n      _ensureParentAndKey: function (parent, key) {\n        this.parent = this.parent || parent\n        this.key = this.key || key\n        if (this.parent !== parent) {\n          throw new Error('Internal Error. Relation retrieved from two different Objects.')\n        }\n        if (this.key !== key) {\n          throw new Error('Internal Error. Relation retrieved from two different keys.')\n        }\n      },\n  \n      /**\n       * Adds a Parse.Object or an array of Parse.Objects to the relation.\n       * @param {} objects The item or items to add.\n       */\n      add: function (objects) {\n        if (!_.isArray(objects)) {\n          objects = [objects]\n        }\n  \n        var change = new Parse.Op.Relation(objects, [])\n        this.parent.set(this.key, change)\n        this.targetClassName = change._targetClassName\n      },\n  \n      /**\n       * Removes a Parse.Object or an array of Parse.Objects from this relation.\n       * @param {} objects The item or items to remove.\n       */\n      remove: function (objects) {\n        if (!_.isArray(objects)) {\n          objects = [objects]\n        }\n  \n        var change = new Parse.Op.Relation([], objects)\n        this.parent.set(this.key, change)\n        this.targetClassName = change._targetClassName\n      },\n  \n      /**\n       * Returns a JSON version of the object suitable for saving to disk.\n       * @return {Object}\n       */\n      toJSON: function () {\n        return { '__type': 'Relation', 'className': this.targetClassName }\n      },\n  \n      /**\n       * Returns a Parse.Query that is limited to objects in this\n       * relation.\n       * @return {Parse.Query}\n       */\n      query: function () {\n        var targetClass\n        var query\n        if (!this.targetClassName) {\n          targetClass = Parse.Object._getSubclass(this.parent.className)\n          query = new Parse.Query(targetClass)\n          query._extraOptions.redirectClassNameForKey = this.key\n        } else {\n          targetClass = Parse.Object._getSubclass(this.targetClassName)\n          query = new Parse.Query(targetClass)\n        }\n        query._addCondition('$relatedTo', 'object', this.parent._toPointer())\n        query._addCondition('$relatedTo', 'key', this.key)\n  \n        return query\n      }\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * A Promise is returned by async methods as a hook to provide callbacks to be\n     * called when the async task is fulfilled.\n     *\n     * <p>Typical usage would be like:<pre>\n     *    query.find().then(function(results) {\n     *      results[0].set(\"foo\", \"bar\")\n     *      return results[0].saveAsync()\n     *    }).then(function(result) {\n     *      console.log(\"Updated \" + result.id)\n     *    })\n     * </pre></p>\n     *\n     * @see Parse.Promise.prototype.then\n     * @class\n     */\n    Parse.Promise = function () {\n      this._resolved = false\n      this._rejected = false\n      this._resolvedCallbacks = []\n      this._rejectedCallbacks = []\n    }\n  \n    _.extend(Parse.Promise, /** @lends Parse.Promise */ {\n      _isPromisesAPlusCompliant: false,\n  \n      /**\n       * Returns true iff the given object fulfils the Promise interface.\n       * @return {Boolean}\n       */\n      is: function (promise) {\n        return promise && promise.then && _.isFunction(promise.then)\n      },\n  \n      /**\n       * Returns a new promise that is resolved with a given value.\n       * @return {Parse.Promise} the new promise.\n       */\n      as: function () {\n        var promise = new Parse.Promise()\n        promise.resolve.apply(promise, arguments)\n        return promise\n      },\n  \n      /**\n       * Returns a new promise that is rejected with a given error.\n       * @return {Parse.Promise} the new promise.\n       */\n      error: function () {\n        var promise = new Parse.Promise()\n        promise.reject.apply(promise, arguments)\n        return promise\n      },\n  \n      /**\n       * Returns a new promise that is fulfilled when all of the input promises\n       * are resolved. If any promise in the list fails, then the returned promise\n       * will fail with the last error. If they all succeed, then the returned\n       * promise will succeed, with the results being the results of all the input\n       * promises. For example: <pre>\n       *   var p1 = Parse.Promise.as(1)\n       *   var p2 = Parse.Promise.as(2)\n       *   var p3 = Parse.Promise.as(3)\n       *\n       *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\n       *     console.log(r1)  // prints 1\n       *     console.log(r2)  // prints 2\n       *     console.log(r3)  // prints 3\n       *   });</pre>\n       *\n       * The input promises can also be specified as an array: <pre>\n       *   var promises = [p1, p2, p3]\n       *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\n       *     console.log(r1)  // prints 1\n       *     console.log(r2)  // prints 2\n       *     console.log(r3)  // prints 3\n       *   })\n       * </pre>\n       * @param {Array} promises a list of promises to wait for.\n       * @return {Parse.Promise} the new promise.\n       */\n      when: function (promises) {\n        // Allow passing in Promises as separate arguments instead of an Array.\n        var objects\n        if (promises && Parse._isNullOrUndefined(promises.length)) {\n          objects = arguments\n        } else {\n          objects = promises\n        }\n  \n        var total = objects.length\n        var hadError = false\n        var results = []\n        var errors = []\n        results.length = objects.length\n        errors.length = objects.length\n  \n        if (total === 0) {\n          return Parse.Promise.as.apply(this, results)\n        }\n  \n        var promise = new Parse.Promise()\n  \n        var resolveOne = function () {\n          total = total - 1\n          if (total === 0) {\n            if (hadError) {\n              promise.reject(errors)\n            } else {\n              promise.resolve.apply(promise, results)\n            }\n          }\n        }\n  \n        Parse._arrayEach(objects, function (object, i) {\n          if (Parse.Promise.is(object)) {\n            object.then(function (result) {\n              results[i] = result\n              resolveOne()\n            }, function (error) {\n              errors[i] = error\n              hadError = true\n              resolveOne()\n            })\n          } else {\n            results[i] = object\n            resolveOne()\n          }\n        })\n  \n        return promise\n      },\n  \n      /**\n       * Runs the given asyncFunction repeatedly, as long as the predicate\n       * function returns a truthy value. Stops repeating if asyncFunction returns\n       * a rejected promise.\n       * @param {Function} predicate should return false when ready to stop.\n       * @param {Function} asyncFunction should return a Promise.\n       */\n      _continueWhile: function (predicate, asyncFunction) {\n        if (predicate()) {\n          return asyncFunction().then(function () {\n            return Parse.Promise._continueWhile(predicate, asyncFunction)\n          })\n        }\n        return Parse.Promise.as()\n      }\n    })\n  \n    _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\n  \n      /**\n       * Marks this promise as fulfilled, firing any callbacks waiting on it.\n       * @param {Object} result the result to pass to the callbacks.\n       */\n      resolve: function (result) {\n        if (this._resolved || this._rejected) {\n          throw new Error('A promise was resolved even though it had already been ' + (this._resolved ? 'resolved' : 'rejected') + '.')\n        }\n        this._resolved = true\n        this._result = arguments\n        var results = arguments\n        Parse._arrayEach(this._resolvedCallbacks, function (resolvedCallback) {\n          resolvedCallback.apply(this, results)\n        })\n        this._resolvedCallbacks = []\n        this._rejectedCallbacks = []\n      },\n  \n      /**\n       * Marks this promise as fulfilled, firing any callbacks waiting on it.\n       * @param {Object} error the error to pass to the callbacks.\n       */\n      reject: function (error) {\n        if (this._resolved || this._rejected) {\n          throw new Error('A promise was rejected even though it had already been ' + (this._resolved ? 'resolved' : 'rejected') + '.')\n        }\n        this._rejected = true\n        this._error = error\n        Parse._arrayEach(this._rejectedCallbacks, function (rejectedCallback) {\n          rejectedCallback(error)\n        })\n        this._resolvedCallbacks = []\n        this._rejectedCallbacks = []\n      },\n  \n      /**\n       * Adds callbacks to be called when this promise is fulfilled. Returns a new\n       * Promise that will be fulfilled when the callback is complete. It allows\n       * chaining. If the callback itself returns a Promise, then the one returned\n       * by \"then\" will not be fulfilled until that one returned by the callback\n       * is fulfilled.\n       * @param {Function} resolvedCallback Function that is called when this\n       * Promise is resolved. Once the callback is complete, then the Promise\n       * returned by \"then\" will also be fulfilled.\n       * @param {Function} rejectedCallback Function that is called when this\n       * Promise is rejected with an error. Once the callback is complete, then\n       * the promise returned by \"then\" with be resolved successfully. If\n       * rejectedCallback is null, or it returns a rejected Promise, then the\n       * Promise returned by \"then\" will be rejected with that error.\n       * @return {Parse.Promise} A new Promise that will be fulfilled after this\n       * Promise is fulfilled and either callback has completed. If the callback\n       * returned a Promise, then this Promise will not be fulfilled until that\n       * one is.\n       */\n      then: function (resolvedCallback, rejectedCallback) {\n        var promise = new Parse.Promise()\n  \n        var wrappedResolvedCallback = function () {\n          var result = arguments\n          if (resolvedCallback) {\n            if (Parse.Promise._isPromisesAPlusCompliant) {\n              try {\n                result = [resolvedCallback.apply(this, result)]\n              } catch (e) {\n                result = [Parse.Promise.error(e)]\n              }\n            } else {\n              result = [resolvedCallback.apply(this, result)]\n            }\n          }\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\n            result[0].then(function () {\n              promise.resolve.apply(promise, arguments)\n            }, function (error) {\n              promise.reject(error)\n            })\n          } else {\n            promise.resolve.apply(promise, result)\n          }\n        }\n  \n        var wrappedRejectedCallback = function (error) {\n          var result = []\n          if (rejectedCallback) {\n            if (Parse.Promise._isPromisesAPlusCompliant) {\n              try {\n                result = [rejectedCallback(error)]\n              } catch (e) {\n                result = [Parse.Promise.error(e)]\n              }\n            } else {\n              result = [rejectedCallback(error)]\n            }\n            if (result.length === 1 && Parse.Promise.is(result[0])) {\n              result[0].then(function () {\n                promise.resolve.apply(promise, arguments)\n              }, function (error) {\n                promise.reject(error)\n              })\n            } else {\n              if (Parse.Promise._isPromisesAPlusCompliant) {\n                promise.resolve.apply(promise, result)\n              } else {\n                promise.reject(result[0])\n              }\n            }\n          } else {\n            promise.reject(error)\n          }\n        }\n  \n        var runLater = function (func) {\n          func.call()\n        }\n        if (Parse.Promise._isPromisesAPlusCompliant) {\n          if (typeof (window) !== 'undefined' && window.setTimeout) {\n            runLater = function (func) {\n              window.setTimeout(func, 0)\n            }\n          } else if (typeof (process) !== 'undefined' && process.nextTick) {\n            runLater = function (func) {\n              process.nextTick(func)\n            }\n          }\n        }\n  \n        var self = this\n        if (this._resolved) {\n          runLater(function () {\n            wrappedResolvedCallback.apply(self, self._result)\n          })\n        } else if (this._rejected) {\n          runLater(function () {\n            wrappedRejectedCallback(self._error)\n          })\n        } else {\n          this._resolvedCallbacks.push(wrappedResolvedCallback)\n          this._rejectedCallbacks.push(wrappedRejectedCallback)\n        }\n  \n        return promise\n      },\n  \n      /**\n       * Add handlers to be called when the promise\n       * is either resolved or rejected\n       */\n      always: function (callback) {\n        return this.then(callback, callback)\n      },\n  \n      /**\n       * Add handlers to be called when the Promise object is resolved\n       */\n      done: function (callback) {\n        return this.then(callback)\n      },\n  \n      /**\n       * Add handlers to be called when the Promise object is rejected\n       */\n      fail: function (callback) {\n        return this.then(null, callback)\n      },\n  \n      /**\n       * Run the given callbacks after this promise is fulfilled.\n       * @param optionsOrCallback {} A Backbone-style options callback, or a\n       * callback function. If this is an options object and contains a \"model\"\n       * attributes, that will be passed to error callbacks as the first argument.\n       * @param model {} If truthy, this will be passed as the first result of\n       * error callbacks. This is for Backbone-compatability.\n       * @return {Parse.Promise} A promise that will be resolved after the\n       * callbacks are run, with the same result as this.\n       */\n      _thenRunCallbacks: function (optionsOrCallback, model) {\n        var options\n        if (_.isFunction(optionsOrCallback)) {\n          var callback = optionsOrCallback\n          options = {\n            success: function (result) {\n              callback(result, null)\n            },\n            error: function (error) {\n              callback(null, error)\n            }\n          }\n        } else {\n          options = _.clone(optionsOrCallback)\n        }\n        options = options || {}\n  \n        return this.then(function (result) {\n          if (options.success) {\n            options.success.apply(this, arguments)\n          } else if (model) {\n            // When there's no callback, a sync event should be triggered.\n            model.trigger('sync', model, result, options)\n          }\n          return Parse.Promise.as.apply(Parse.Promise, arguments)\n        }, function (error) {\n          if (options.error) {\n            if (!_.isUndefined(model)) {\n              options.error(model, error)\n            } else {\n              options.error(error)\n            }\n          } else if (model) {\n            // When there's no error callback, an error event should be triggered.\n            model.trigger('error', model, error, options)\n          }\n          // By explicitly returning a rejected Promise, this will work with\n          // either jQuery or Promises/A semantics.\n          return Parse.Promise.error(error)\n        })\n      },\n  \n      /**\n       * Adds a callback function that should be called regardless of whether\n       * this promise failed or succeeded. The callback will be given either the\n       * array of results for its first argument, or the error as its second,\n       * depending on whether this Promise was rejected or resolved. Returns a\n       * new Promise, like \"then\" would.\n       * @param {Function} continuation the callback.\n       */\n      _continueWith: function (continuation) {\n        return this.then(function () {\n          return continuation(arguments, null)\n        }, function (error) {\n          return continuation(null, error)\n        })\n      }\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    var b64Digit = function (number) {\n      if (number < 26) {\n        return String.fromCharCode(65 + number)\n      }\n      if (number < 52) {\n        return String.fromCharCode(97 + (number - 26))\n      }\n      if (number < 62) {\n        return String.fromCharCode(48 + (number - 52))\n      }\n      if (number === 62) {\n        return '+'\n      }\n      if (number === 63) {\n        return '/'\n      }\n      throw new Error('Tried to encode large digit ' + number + ' in base64.')\n    }\n  \n    var encodeBase64 = function (array) {\n      var chunks = []\n      chunks.length = Math.ceil(array.length / 3)\n      _.times(chunks.length, function (i) {\n        var b1 = array[i * 3]\n        var b2 = array[i * 3 + 1] || 0\n        var b3 = array[i * 3 + 2] || 0\n  \n        var has2 = (i * 3 + 1) < array.length\n        var has3 = (i * 3 + 2) < array.length\n  \n        chunks[i] = [\n          b64Digit((b1 >> 2) & 0x3F),\n          b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\n          has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : '=',\n          has3 ? b64Digit(b3 & 0x3F) : '='\n        ].join('')\n      })\n      return chunks.join('')\n    }\n  \n    /**\n     * Reads a File using a FileReader.\n     * @param file {File} the File to read.\n     * @param type {String} (optional) the mimetype to override with.\n     * @return {Parse.Promise} A Promise that will be fulfilled with a\n     *     base64-encoded string of the data and its mime type.\n     */\n    var readAsync = function (file, type) {\n      var promise = new Parse.Promise()\n  \n      if (typeof (FileReader) === 'undefined') {\n        return Parse.Promise.error(new Parse.Error(\n          Parse.Error.FILE_READ_ERROR,\n          'Attempted to use a FileReader on an unsupported browser.'))\n      }\n  \n      var reader = new FileReader()\n      reader.onloadend = function () {\n        if (reader.readyState !== 2) {\n          promise.reject(new Parse.Error(\n            Parse.Error.FILE_READ_ERROR,\n            'Error reading file.'))\n          return\n        }\n  \n        var dataURL = reader.result\n        var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL)\n        if (!matches) {\n          promise.reject(new Parse.Error(\n            Parse.Error.FILE_READ_ERROR,\n            'Unable to interpret data URL: ' + dataURL))\n          return\n        }\n  \n        promise.resolve(matches[2], type || matches[1])\n      }\n      reader.readAsDataURL(file)\n      return promise\n    }\n  \n    /**\n     * A Parse.File is a local representation of a file that is saved to the Parse\n     * cloud.\n     * @class\n     * @param name {String} The file's name. This will be prefixed by a unique\n     *     value once the file has finished saving. The file name must begin with\n     *     an alphanumeric character, and consist of alphanumeric characters,\n     *     periods, spaces, underscores, or dashes.\n     * @param data {Array} The data for the file, as either:\n     *     1. an Array of byte value Numbers, or\n     *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n     *     3. a File object selected with a file upload control. (3) only works\n     *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n     *        For example:<pre>\n     * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0]\n     * if (fileUploadControl.files.length > 0) {\n     *   var file = fileUploadControl.files[0]\n     *   var name = \"photo.jpg\"\n     *   var parseFile = new Parse.File(name, file)\n     *   parseFile.save().then(function() {\n     *     // The file has been saved to Parse.\n     *   }, function(error) {\n     *     // The file either could not be read, or could not be saved to Parse.\n     *   })\n     * }</pre>\n     * @param type {String} Optional Content-Type header to use for the file. If\n     *     this is omitted, the content type will be inferred from the name's\n     *     extension.\n     */\n    Parse.File = function (name, data, type) {\n      this._name = name\n  \n      // Guess the content type from the extension if we need to.\n      var extension = /\\.([^.]*)$/.exec(name)\n      if (extension) {\n        extension = extension[1].toLowerCase()\n      }\n      var specifiedType = type || ''\n  \n      if (_.isArray(data)) {\n        this._source = Parse.Promise.as(encodeBase64(data), specifiedType)\n      } else if (data && data.base64) {\n        // if it contains data uri, extract based64 and the type out of it.\n        var dataUriRegexp = /^data:([a-zA-Z]*\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\-\\/\\s]*,)?base64,(\\S+)/\n  \n        var matches = dataUriRegexp.exec(data.base64)\n        if (matches && matches.length > 0) {\n          // if data URI with charset, there will have 4 matches.\n          this._source = Parse.Promise.as(\n            (matches.length === 4 ? matches[3] : matches[2]), matches[1]\n          )\n        } else {\n          this._source = Parse.Promise.as(data.base64, specifiedType)\n        }\n      } else if (typeof (File) !== 'undefined' && data instanceof File) {\n        this._source = readAsync(data, type)\n      } else if (_.isString(data)) {\n        throw new Error('Creating a Parse.File from a String is not yet supported.')\n      }\n    }\n  \n    Parse.File.prototype = {\n  \n      /**\n       * Gets the name of the file. Before save is called, this is the filename\n       * given by the user. After save is called, that name gets prefixed with a\n       * unique identifier.\n       */\n      name: function () {\n        return this._name\n      },\n  \n      /**\n       * Gets the url of the file. It is only available after you save the file or\n       * after you get the file from a Parse.Object.\n       * @return {String}\n       */\n      url: function () {\n        return this._url\n      },\n  \n      /**\n       * Saves the file to the Parse cloud.\n       * @param {Object} options A Backbone-style options object.\n       * @return {Parse.Promise} Promise that is resolved when the save finishes.\n       */\n      save: function (options) {\n        options = options || {}\n  \n        var self = this\n        if (!self._previousSave) {\n          self._previousSave = self._source.then(function (base64, type) {\n            var data = {\n              base64: base64,\n              _ContentType: type\n            }\n            return Parse._request({\n              route: 'files',\n              className: self._name,\n              method: 'POST',\n              data: data,\n              useMasterKey: options.useMasterKey\n            })\n          }).then(function (response) {\n            self._name = response.name\n            self._url = response.url\n            return self\n          })\n        }\n        return self._previousSave._thenRunCallbacks(options)\n      }\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creates a new model with defined attributes. A client id (cid) is\n     * automatically generated and assigned for you.\n     *\n     * <p>You won't normally call this method directly.  It is recommended that\n     * you use a subclass of <code>Parse.Object</code> instead, created by calling\n     * <code>extend</code>.</p>\n     *\n     * <p>However, if you don't want to use a subclass, or aren't sure which\n     * subclass is appropriate, you can use this form:<pre>\n     *     var object = new Parse.Object(\"ClassName\")\n     * </pre>\n     * That is basically equivalent to:<pre>\n     *     var MyClass = Parse.Object.extend(\"ClassName\")\n     *     var object = new MyClass()\n     * </pre></p>\n     *\n     * @param {Object} attributes The initial set of data to store in the object.\n     * @param {Object} options A set of Backbone-like options for creating the\n     *     object.  The only option currently supported is \"collection\".\n     * @see Parse.Object.extend\n     *\n     * @class\n     *\n     * <p>The fundamental unit of Parse data, which implements the Backbone Model\n     * interface.</p>\n     */\n    Parse.Object = function (attributes, options) {\n      // Allow new Parse.Object(\"ClassName\") as a shortcut to _create.\n      if (_.isString(attributes)) {\n        return Parse.Object._create.apply(this, arguments)\n      }\n  \n      attributes = attributes || {}\n      if (options && options.parse) {\n        attributes = this.parse(attributes)\n      }\n      var defaults = Parse._getValue(this, 'defaults')\n      if (defaults) {\n        attributes = _.extend({}, defaults, attributes)\n      }\n      if (options && options.collection) {\n        this.collection = options.collection\n      }\n  \n      this._serverData = {} // The last known data for this object from cloud.\n      this._opSetQueue = [{}] // List of sets of changes to the data.\n      this.attributes = {} // The best estimate of this's current data.\n  \n      this._hashedJSON = {} // Hash of values of containers at last save.\n      this._escapedAttributes = {}\n      this.cid = _.uniqueId('c')\n      this.changed = {}\n      this._silent = {}\n      this._pending = {}\n      if (!this.set(attributes, {silent: true})) {\n        throw new Error(\"Can't create an invalid Parse.Object\")\n      }\n      this.changed = {}\n      this._silent = {}\n      this._pending = {}\n      this._hasData = true\n      this._previousAttributes = _.clone(this.attributes)\n      this.initialize.apply(this, arguments)\n    }\n  \n    /**\n     * The ID of this object, unique within its class.\n     * @name id\n     * @type String\n     * @field\n     * @memberOf Parse.Object.prototype\n     */\n  \n    /**\n     * The first time this object was saved on the server.\n     * @name createdAt\n     * @type Date\n     * @field\n     * @memberOf Parse.Object.prototype\n     */\n  \n    /**\n     * The last time this object was updated on the server.\n     * @name updatedAt\n     * @type Date\n     * @field\n     * @memberOf Parse.Object.prototype\n     */\n  \n    /**\n     * Saves the given list of Parse.Object.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.saveAll([object1, object2, ...], {\n     *     success: function(list) {\n     *       // All the objects were saved.\n     *     },\n     *     error: function(error) {\n     *       // An error occurred while saving one of the objects.\n     *     },\n     *   })\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     */\n    Parse.Object.saveAll = function (list, options) {\n      options = options || {}\n      return Parse.Object._deepSaveAsync(list, {\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken\n      })._thenRunCallbacks(options)\n    }\n  \n    /**\n     * Destroy the given list of models on the server if it was already persisted.\n     * Optimistically removes each model from its collection, if it has one.\n     * If `wait: true` is passed, waits for the server to respond before removal.\n     *\n     * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n     * this method will continue trying to delete the rest of the models if\n     * possible, except in the case of a fatal error like a connection error.\n     *\n     * <p>In particular, the Parse.Error object returned in the case of error may\n     * be one of two types:\n     *\n     * <ul>\n     *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n     *       array of other Parse.Error objects. Each error object in this array\n     *       has an \"object\" property that references the object that could not be\n     *       deleted (for instance, because that object could not be found).</li>\n     *   <li>A non-aggregate Parse.Error. This indicates a serious error that\n     *       caused the delete operation to be aborted partway through (for\n     *       instance, a connection failure in the middle of the delete).</li>\n     * </ul>\n     *\n     * <pre>\n     *   Parse.Object.destroyAll([object1, object2, ...], {\n     *     success: function() {\n     *       // All the objects were deleted.\n     *     },\n     *     error: function(error) {\n     *       // An error occurred while deleting one or more of the objects.\n     *       // If this is an aggregate error, then we can inspect each error\n     *       // object individually to determine the reason why a particular\n     *       // object was not deleted.\n     *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\n     *         for (var i = 0; i < error.errors.length; i++) {\n     *           console.log(\"Couldn't delete \" + error.errors[i].object.id +\n     *             \"due to \" + error.errors[i].message)\n     *         }\n     *       } else {\n     *         console.log(\"Delete aborted because of \" + error.message)\n     *       }\n     *     },\n     *   })\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the destroyAll\n     *     completes.\n     */\n    Parse.Object.destroyAll = function (list, options) {\n      options = options || {}\n  \n      var triggerDestroy = function (object) {\n        object.trigger('destroy', object, object.collection, options)\n      }\n  \n      var errors = []\n      var destroyBatch = function (batch) {\n        var promise = Parse.Promise.as()\n  \n        if (batch.length > 0) {\n          promise = promise.then(function () {\n            return Parse._request({\n              route: 'batch',\n              method: 'POST',\n              useMasterKey: options.useMasterKey,\n              sessionToken: options.sessionToken,\n              data: {\n                requests: _.map(batch, function (object) {\n                  return {\n                    method: 'DELETE',\n                    path: '/1/classes/' + object.className + '/' + object.id\n                  }\n                })\n              }\n            })\n          }).then(function (responses, status, xhr) {\n            Parse._arrayEach(batch, function (object, i) {\n              if (responses[i].success && options.wait) {\n                triggerDestroy(object)\n              } else if (responses[i].error) {\n                var error = new Parse.Error(responses[i].error.code,\n                  responses[i].error.error)\n                error.object = object\n  \n                errors.push(error)\n              }\n            })\n          })\n        }\n  \n        return promise\n      }\n  \n      var promise = Parse.Promise.as()\n      var batch = []\n      Parse._arrayEach(list, function (object, i) {\n        if (!object.id || !options.wait) {\n          triggerDestroy(object)\n        }\n  \n        if (object.id) {\n          batch.push(object)\n        }\n  \n        if (batch.length === 20 || i + 1 === list.length) {\n          var thisBatch = batch\n          batch = []\n  \n          promise = promise.then(function () {\n            return destroyBatch(thisBatch)\n          })\n        }\n      })\n  \n      return promise.then(function () {\n        if (errors.length === 0) {\n          return true\n        } else {\n          var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\n            'Error deleting an object in destroyAll')\n          error.errors = errors\n  \n          return Parse.Promise.error(error)\n        }\n      })._thenRunCallbacks(options)\n    }\n  \n    /**\n     * Fetches the given list of Parse.Object.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.fetchAll([object1, object2, ...], {\n     *     success: function(list) {\n     *       // All the objects were fetched.\n     *     },\n     *     error: function(error) {\n     *       // An error occurred while fetching one of the objects.\n     *     },\n     *   })\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     * </ul>\n     */\n    Parse.Object.fetchAll = function (list, options) {\n      return Parse.Object._fetchAll(\n        list,\n        true\n      )._thenRunCallbacks(options)\n    }\n  \n    /**\n     * Fetches the given list of Parse.Object if needed.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.fetchAllIfNeeded([object1, ...], {\n     *     success: function(list) {\n     *       // Objects were fetched and updated.\n     *     },\n     *     error: function(error) {\n     *       // An error occurred while fetching one of the objects.\n     *     },\n     *   })\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     * </ul>\n     */\n    Parse.Object.fetchAllIfNeeded = function (list, options) {\n      return Parse.Object._fetchAll(\n        list,\n        false\n      )._thenRunCallbacks(options)\n    }\n  \n    // Attach all inheritable methods to the Parse.Object prototype.\n    _.extend(Parse.Object.prototype, Parse.Events, {\n      _existed: false,\n  \n      /**\n       * Initialize is an empty function by default. Override it with your own\n       * initialization logic.\n       */\n      initialize: function () {},\n  \n      /**\n       * Returns a JSON version of the object suitable for saving to Parse.\n       * @return {Object}\n       */\n      toJSON: function () {\n        var json = this._toFullJSON()\n        Parse._arrayEach(['__type', 'className'], function (key) {\n          delete json[key]\n        })\n        return json\n      },\n  \n      _toFullJSON: function (seenObjects) {\n        var json = _.clone(this.attributes)\n        Parse._objectEach(json, function (val, key) {\n          json[key] = Parse._encode(val, seenObjects)\n        })\n        Parse._objectEach(this._operations, function (val, key) {\n          json[key] = val\n        })\n  \n        if (_.has(this, 'id')) {\n          json.objectId = this.id\n        }\n        if (_.has(this, 'createdAt')) {\n          if (_.isDate(this.createdAt)) {\n            json.createdAt = this.createdAt.toJSON()\n          } else {\n            json.createdAt = this.createdAt\n          }\n        }\n  \n        if (_.has(this, 'updatedAt')) {\n          if (_.isDate(this.updatedAt)) {\n            json.updatedAt = this.updatedAt.toJSON()\n          } else {\n            json.updatedAt = this.updatedAt\n          }\n        }\n        json.__type = 'Object'\n        json.className = this.className\n        return json\n      },\n  \n      /**\n       * Updates _hashedJSON to reflect the current state of this object.\n       * Adds any changed hash values to the set of pending changes.\n       */\n      _refreshCache: function () {\n        var self = this\n        if (self._refreshingCache) {\n          return\n        }\n        self._refreshingCache = true\n        Parse._objectEach(this.attributes, function (value, key) {\n          if (value instanceof Parse.Object) {\n            value._refreshCache()\n          } else if (_.isObject(value)) {\n            var objectArray = false\n            if (_.isArray(value)) {\n              // We don't cache arrays of Parse.Objects\n              _.each(value, function (arrVal) {\n                if (arrVal instanceof Parse.Object) {\n                  objectArray = true\n                  arrVal._refreshCache()\n                }\n              })\n            }\n            if (!objectArray && self._resetCacheForKey(key)) {\n              self.set(key, new Parse.Op.Set(value), { silent: true })\n            }\n          }\n        })\n        delete self._refreshingCache\n      },\n  \n      /**\n       * Returns true if this object has been modified since its last\n       * save/refresh.  If an attribute is specified, it returns true only if that\n       * particular attribute has been modified since the last save/refresh.\n       * @param {String} attr An attribute name (optional).\n       * @return {Boolean}\n       */\n      dirty: function (attr) {\n        this._refreshCache()\n  \n        var currentChanges = _.last(this._opSetQueue)\n  \n        if (attr) {\n          return !!(currentChanges[attr])\n        }\n        if (!this.id) {\n          return true\n        }\n        if (_.keys(currentChanges).length > 0) {\n          return true\n        }\n        return false\n      },\n  \n      /**\n       * Returns an array of keys that have been modified since last save/refresh\n       * @return {Array of string}\n       */\n      dirtyKeys: function () {\n        return _.keys(_.last(this._opSetQueue))\n      },\n  \n      /**\n       * Gets a Pointer referencing this Object.\n       */\n      _toPointer: function () {\n        if (!this.id) {\n          throw new Error(\"Can't serialize an unsaved Parse.Object\")\n        }\n        return { __type: 'Pointer',\n          className: this.className,\n        objectId: this.id }\n      },\n  \n      /**\n       * Gets the value of an attribute.\n       * @param {String} attr The string name of an attribute.\n       */\n      get: function (attr) {\n        return this.attributes[attr]\n      },\n  \n      /**\n       * Gets a relation on the given class for the attribute.\n       * @param String attr The attribute to get the relation for.\n       */\n      relation: function (attr) {\n        var value = this.get(attr)\n        if (value) {\n          if (!(value instanceof Parse.Relation)) {\n            throw new Error('Called relation() on non-relation field ' + attr)\n          }\n          value._ensureParentAndKey(this, attr)\n          return value\n        } else {\n          return new Parse.Relation(this, attr)\n        }\n      },\n  \n      /**\n       * Gets the HTML-escaped value of an attribute.\n       */\n      escape: function (attr) {\n        var html = this._escapedAttributes[attr]\n        if (html) {\n          return html\n        }\n        var val = this.attributes[attr]\n        var escaped\n        if (Parse._isNullOrUndefined(val)) {\n          escaped = ''\n        } else {\n          escaped = _.escape(val.toString())\n        }\n        this._escapedAttributes[attr] = escaped\n        return escaped\n      },\n  \n      /**\n       * Returns <code>true</code> if the attribute contains a value that is not\n       * null or undefined.\n       * @param {String} attr The string name of the attribute.\n       * @return {Boolean}\n       */\n      has: function (attr) {\n        return !Parse._isNullOrUndefined(this.attributes[attr])\n      },\n  \n      /**\n       * Pulls \"special\" fields like objectId, createdAt, etc. out of attrs\n       * and puts them on \"this\" directly.  Removes them from attrs.\n       * @param attrs - A dictionary with the data for this Parse.Object.\n       */\n      _mergeMagicFields: function (attrs) {\n        // Check for changes of magic fields.\n        var model = this\n        var specialFields = ['id', 'objectId', 'createdAt', 'updatedAt']\n        Parse._arrayEach(specialFields, function (attr) {\n          if (attrs[attr]) {\n            if (attr === 'objectId') {\n              model.id = attrs[attr]\n            } else if ((attr === 'createdAt' || attr === 'updatedAt') &&\n              !_.isDate(attrs[attr])) {\n              model[attr] = Parse._parseDate(attrs[attr])\n            } else {\n              model[attr] = attrs[attr]\n            }\n            delete attrs[attr]\n          }\n        })\n      },\n  \n      /**\n       * Copies the given serverData to \"this\", refreshes attributes, and\n       * clears pending changes\n       */\n      _copyServerData: function (serverData) {\n        // Copy server data\n        var tempServerData = {}\n        Parse._objectEach(serverData, function (value, key) {\n          tempServerData[key] = Parse._decode(key, value)\n        })\n        this._serverData = tempServerData\n  \n        // Refresh the attributes.\n        this._rebuildAllEstimatedData()\n  \n        // Clear out any changes the user might have made previously.\n        this._refreshCache()\n        this._opSetQueue = [{}]\n  \n        // Refresh the attributes again.\n        this._rebuildAllEstimatedData()\n      },\n  \n      /**\n       * Merges another object's attributes into this object.\n       */\n      _mergeFromObject: function (other) {\n        if (!other) {\n          return\n        }\n  \n        // This does the inverse of _mergeMagicFields.\n        this.id = other.id\n        this.createdAt = other.createdAt\n        this.updatedAt = other.updatedAt\n  \n        this._copyServerData(other._serverData)\n  \n        this._hasData = true\n      },\n  \n      /**\n       * Returns the json to be sent to the server.\n       */\n      _startSave: function () {\n        this._opSetQueue.push({})\n      },\n  \n      /**\n       * Called when a save fails because of an error. Any changes that were part\n       * of the save need to be merged with changes made after the save. This\n       * might throw an exception is you do conflicting operations. For example,\n       * if you do:\n       *   object.set(\"foo\", \"bar\")\n       *   object.set(\"invalid field name\", \"baz\")\n       *   object.save()\n       *   object.increment(\"foo\")\n       * then this will throw when the save fails and the client tries to merge\n       * \"bar\" with the +1.\n       */\n      _cancelSave: function () {\n        var failedChanges = _.first(this._opSetQueue)\n        this._opSetQueue = _.rest(this._opSetQueue)\n        var nextChanges = _.first(this._opSetQueue)\n        Parse._objectEach(failedChanges, function (op, key) {\n          var op1 = failedChanges[key]\n          var op2 = nextChanges[key]\n          if (op1 && op2) {\n            nextChanges[key] = op2._mergeWithPrevious(op1)\n          } else if (op1) {\n            nextChanges[key] = op1\n          }\n        })\n        this._saving = this._saving - 1\n      },\n  \n      /**\n       * Called when a save completes successfully. This merges the changes that\n       * were saved into the known server data, and overrides it with any data\n       * sent directly from the server.\n       */\n      _finishSave: function (serverData) {\n        // Grab a copy of any object referenced by this object. These instances\n        // may have already been fetched, and we don't want to lose their data.\n        // Note that doing it like this means we will unify separate copies of the\n        // same object, but that's a risk we have to take.\n        var fetchedObjects = {}\n        Parse._traverse(this.attributes, function (object) {\n          if (object instanceof Parse.Object && object.id && object._hasData) {\n            fetchedObjects[object.id] = object\n          }\n        })\n  \n        var savedChanges = _.first(this._opSetQueue)\n        this._opSetQueue = _.rest(this._opSetQueue)\n        this._applyOpSet(savedChanges, this._serverData)\n        this._mergeMagicFields(serverData)\n        var self = this\n        Parse._objectEach(serverData, function (value, key) {\n          self._serverData[key] = Parse._decode(key, value)\n  \n          // Look for any objects that might have become unfetched and fix them\n          // by replacing their values with the previously observed values.\n          var fetched = Parse._traverse(self._serverData[key], function (object) {\n            if (object instanceof Parse.Object && fetchedObjects[object.id]) {\n              return fetchedObjects[object.id]\n            }\n          })\n          if (fetched) {\n            self._serverData[key] = fetched\n          }\n        })\n        this._rebuildAllEstimatedData()\n        this._saving = this._saving - 1\n      },\n  \n      /**\n       * Called when a fetch or login is complete to set the known server data to\n       * the given object.\n       */\n      _finishFetch: function (serverData, hasData) {\n        this._opSetQueue = [{}]\n  \n        // Bring in all the new server data.\n        this._mergeMagicFields(serverData)\n        this._copyServerData(serverData)\n  \n        this._hasData = hasData\n      },\n  \n      /**\n       * Applies the set of Parse.Op in opSet to the object target.\n       */\n      _applyOpSet: function (opSet, target) {\n        var self = this\n        Parse._objectEach(opSet, function (change, key) {\n          target[key] = change._estimate(target[key], self, key)\n          if (target[key] === Parse.Op._UNSET) {\n            delete target[key]\n          }\n        })\n      },\n  \n      /**\n       * Replaces the cached value for key with the current value.\n       * Returns true if the new value is different than the old value.\n       */\n      _resetCacheForKey: function (key) {\n        var value = this.attributes[key]\n        if (_.isObject(value) &&\n          !(value instanceof Parse.Object) &&\n          !(value instanceof Parse.File)) {\n          value = value.toJSON ? value.toJSON() : value\n          var json = JSON.stringify(value)\n          if (this._hashedJSON[key] !== json) {\n            var wasSet = !!this._hashedJSON[key]\n            this._hashedJSON[key] = json\n            return wasSet\n          }\n        }\n        return false\n      },\n  \n      /**\n       * Populates attributes[key] by starting with the last known data from the\n       * server, and applying all of the local changes that have been made to that\n       * key since then.\n       */\n      _rebuildEstimatedDataForKey: function (key) {\n        var self = this\n        delete this.attributes[key]\n        if (this._serverData[key]) {\n          this.attributes[key] = this._serverData[key]\n        }\n        Parse._arrayEach(this._opSetQueue, function (opSet) {\n          var op = opSet[key]\n          if (op) {\n            self.attributes[key] = op._estimate(self.attributes[key], self, key)\n            if (self.attributes[key] === Parse.Op._UNSET) {\n              delete self.attributes[key]\n            } else {\n              self._resetCacheForKey(key)\n            }\n          }\n        })\n      },\n  \n      /**\n       * Populates attributes by starting with the last known data from the\n       * server, and applying all of the local changes that have been made since\n       * then.\n       */\n      _rebuildAllEstimatedData: function () {\n        var self = this\n  \n        var previousAttributes = _.clone(this.attributes)\n  \n        this.attributes = _.clone(this._serverData)\n        Parse._arrayEach(this._opSetQueue, function (opSet) {\n          self._applyOpSet(opSet, self.attributes)\n          Parse._objectEach(opSet, function (op, key) {\n            self._resetCacheForKey(key)\n          })\n        })\n  \n        // Trigger change events for anything that changed because of the fetch.\n        Parse._objectEach(previousAttributes, function (oldValue, key) {\n          if (self.attributes[key] !== oldValue) {\n            self.trigger('change:' + key, self, self.attributes[key], {})\n          }\n        })\n        Parse._objectEach(this.attributes, function (newValue, key) {\n          if (!_.has(previousAttributes, key)) {\n            self.trigger('change:' + key, self, newValue, {})\n          }\n        })\n      },\n  \n      /**\n       * Sets a hash of model attributes on the object, firing\n       * <code>\"change\"</code> unless you choose to silence it.\n       *\n       * <p>You can call it with an object containing keys and values, or with one\n       * key and value.  For example:<pre>\n       *   gameTurn.set({\n       *     player: player1,\n       *     diceRoll: 2\n       *   }, {\n       *     error: function(gameTurnAgain, error) {\n       *       // The set failed validation.\n       *     }\n       *   })\n       *\n       *   game.set(\"currentPlayer\", player2, {\n       *     error: function(gameTurnAgain, error) {\n       *       // The set failed validation.\n       *     }\n       *   })\n       *\n       *   game.set(\"finished\", true);</pre></p>\n       *\n       * @param {String} key The key to set.\n       * @param {} value The value to give it.\n       * @param {Object} options A set of Backbone-like options for the set.\n       *     The only supported options are <code>silent</code>,\n       *     <code>error</code>, and <code>promise</code>.\n       * @return {Boolean} true if the set succeeded.\n       * @see Parse.Object#validate\n       * @see Parse.Error\n       */\n      set: function (key, value, options) {\n        var attrs\n        if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\n          attrs = key\n          Parse._objectEach(attrs, function (v, k) {\n            attrs[k] = Parse._decode(k, v)\n          })\n          options = value\n        } else {\n          attrs = {}\n          attrs[key] = Parse._decode(key, value)\n        }\n  \n        // Extract attributes and options.\n        options = options || {}\n        if (!attrs) {\n          return this\n        }\n        if (attrs instanceof Parse.Object) {\n          attrs = attrs.attributes\n        }\n  \n        var self = this\n        Parse._objectEach(attrs, function (unusedValue, key) {\n          if (self.constructor.readOnlyAttributes &&\n            self.constructor.readOnlyAttributes[key]) {\n            throw new Error('Cannot modify readonly key: ' + key)\n          }\n        })\n  \n        // If the unset option is used, every attribute should be a Unset.\n        if (options.unset) {\n          Parse._objectEach(attrs, function (unusedValue, key) {\n            attrs[key] = new Parse.Op.Unset()\n          })\n        }\n  \n        // Apply all the attributes to get the estimated values.\n        var dataToValidate = _.clone(attrs)\n        Parse._objectEach(dataToValidate, function (value, key) {\n          if (value instanceof Parse.Op) {\n            dataToValidate[key] = value._estimate(self.attributes[key],\n              self, key)\n            if (dataToValidate[key] === Parse.Op._UNSET) {\n              delete dataToValidate[key]\n            }\n          }\n        })\n  \n        // Run validation.\n        if (!this._validate(attrs, options)) {\n          return false\n        }\n  \n        this._mergeMagicFields(attrs)\n  \n        options.changes = {}\n        var escaped = this._escapedAttributes\n  \n        // Update attributes.\n        Parse._arrayEach(_.keys(attrs), function (attr) {\n          var val = attrs[attr]\n  \n          // If this is a relation object we need to set the parent correctly,\n          // since the location where it was parsed does not have access to\n          // this object.\n          if (val instanceof Parse.Relation) {\n            val.parent = self\n          }\n  \n          if (!(val instanceof Parse.Op)) {\n            val = new Parse.Op.Set(val)\n          }\n  \n          // See if this change will actually have any effect.\n          var isRealChange = true\n          if (val instanceof Parse.Op.Set && _.isEqual(self.attributes[attr], val.value)) {\n            isRealChange = false\n          }\n  \n          if (isRealChange) {\n            delete escaped[attr]\n            if (options.silent) {\n              self._silent[attr] = true\n            } else {\n              options.changes[attr] = true\n            }\n          }\n  \n          var currentChanges = _.last(self._opSetQueue)\n          currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr])\n          self._rebuildEstimatedDataForKey(attr)\n  \n          if (isRealChange) {\n            self.changed[attr] = self.attributes[attr]\n            if (!options.silent) {\n              self._pending[attr] = true\n            }\n          } else {\n            delete self.changed[attr]\n            delete self._pending[attr]\n          }\n        })\n  \n        if (!options.silent) {\n          this.change(options)\n        }\n        return this\n      },\n  \n      /**\n       * Remove an attribute from the model, firing <code>\"change\"</code> unless\n       * you choose to silence it. This is a noop if the attribute doesn't\n       * exist.\n       */\n      unset: function (attr, options) {\n        options = options || {}\n        options.unset = true\n        return this.set(attr, null, options)\n      },\n  \n      /**\n       * Atomically increments the value of the given attribute the next time the\n       * object is saved. If no amount is specified, 1 is used by default.\n       *\n       * @param attr {String} The key.\n       * @param amount {Number} The amount to increment by.\n       */\n      increment: function (attr, amount) {\n        if (_.isUndefined(amount) || _.isNull(amount)) {\n          amount = 1\n        }\n        return this.set(attr, new Parse.Op.Increment(amount))\n      },\n  \n      /**\n       * Atomically add an object to the end of the array associated with a given\n       * key.\n       * @param attr {String} The key.\n       * @param item {} The item to add.\n       */\n      add: function (attr, item) {\n        return this.set(attr, new Parse.Op.Add([item]))\n      },\n  \n      /**\n       * Atomically add an object to the array associated with a given key, only\n       * if it is not already present in the array. The position of the insert is\n       * not guaranteed.\n       *\n       * @param attr {String} The key.\n       * @param item {} The object to add.\n       */\n      addUnique: function (attr, item) {\n        return this.set(attr, new Parse.Op.AddUnique([item]))\n      },\n  \n      /**\n       * Atomically remove all instances of an object from the array associated\n       * with a given key.\n       *\n       * @param attr {String} The key.\n       * @param item {} The object to remove.\n       */\n      remove: function (attr, item) {\n        return this.set(attr, new Parse.Op.Remove([item]))\n      },\n  \n      /**\n       * Returns an instance of a subclass of Parse.Op describing what kind of\n       * modification has been performed on this field since the last time it was\n       * saved. For example, after calling object.increment(\"x\"), calling\n       * object.op(\"x\") would return an instance of Parse.Op.Increment.\n       *\n       * @param attr {String} The key.\n       * @returns {Parse.Op} The operation, or undefined if none.\n       */\n      op: function (attr) {\n        return _.last(this._opSetQueue)[attr]\n      },\n  \n      /**\n       * Clear all attributes on the model, firing <code>\"change\"</code> unless\n       * you choose to silence it.\n       */\n      clear: function (options) {\n        options = options || {}\n        options.unset = true\n        var keysToClear = _.extend(this.attributes, this._operations)\n        return this.set(keysToClear, options)\n      },\n  \n      /**\n       * Returns a JSON-encoded set of operations to be sent with the next save\n       * request.\n       */\n      _getSaveJSON: function () {\n        var json = _.clone(_.first(this._opSetQueue))\n        Parse._objectEach(json, function (op, key) {\n          json[key] = op.toJSON()\n        })\n        return json\n      },\n  \n      /**\n       * Returns true if this object can be serialized for saving.\n       */\n      _canBeSerialized: function () {\n        return Parse.Object._canBeSerializedAsValue(this.attributes)\n      },\n  \n      /**\n       * Fetch the model from the server. If the server's representation of the\n       * model differs from its current attributes, they will be overriden,\n       * triggering a <code>\"change\"</code> event.\n       *\n       * @param {Object} options A Backbone-style callback object.\n       * Valid options are:<ul>\n       *   <li>success: A Backbone-style success callback.\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       * @return {Parse.Promise} A promise that is fulfilled when the fetch\n       *     completes.\n       */\n      fetch: function (options) {\n        var self = this\n        options = options || {}\n        var request = Parse._request({\n          method: 'GET',\n          route: 'classes',\n          className: this.className,\n          objectId: this.id,\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken\n        })\n        return request.then(function (response, status, xhr) {\n          self._finishFetch(self.parse(response, status, xhr), true)\n          return self\n        })._thenRunCallbacks(options, this)\n      },\n  \n      /**\n       * Set a hash of model attributes, and save the model to the server.\n       * updatedAt will be updated when the request returns.\n       * You can either call it as:<pre>\n       *   object.save();</pre>\n       * or<pre>\n       *   object.save(null, options);</pre>\n       * or<pre>\n       *   object.save(attrs, options);</pre>\n       * or<pre>\n       *   object.save(key, value, options);</pre>\n       *\n       * For example, <pre>\n       *   gameTurn.save({\n       *     player: \"Jake Cutter\",\n       *     diceRoll: 2\n       *   }, {\n       *     success: function(gameTurnAgain) {\n       *       // The save was successful.\n       *     },\n       *     error: function(gameTurnAgain, error) {\n       *       // The save failed.  Error is an instance of Parse.Error.\n       *     }\n       *   });</pre>\n       * or with promises:<pre>\n       *   gameTurn.save({\n       *     player: \"Jake Cutter\",\n       *     diceRoll: 2\n       *   }).then(function(gameTurnAgain) {\n       *     // The save was successful.\n       *   }, function(error) {\n       *     // The save failed.  Error is an instance of Parse.Error.\n       *   });</pre>\n       *\n       * @param {Object} options A Backbone-style callback object.\n       * Valid options are:<ul>\n       *   <li>wait: Set to true to wait for the server to confirm a successful\n       *   save before modifying the attributes on the object.\n       *   <li>silent: Set to true to avoid firing the `set` event.\n       *   <li>success: A Backbone-style success callback.\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       * @return {Parse.Promise} A promise that is fulfilled when the save\n       *     completes.\n       * @see Parse.Error\n       */\n      save: function (arg1, arg2, arg3) {\n        var attrs, current, options\n        if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\n          attrs = arg1\n          options = arg2\n        } else {\n          attrs = {}\n          attrs[arg1] = arg2\n          options = arg3\n        }\n  \n        // Make save({ success: function() {} }) work.\n        if (!options && attrs) {\n          var extraKeys = _.reject(attrs, function (value, key) {\n            return _.include(['success', 'error', 'wait'], key)\n          })\n          if (extraKeys.length === 0) {\n            var allFunctions = true\n            if (_.has(attrs, 'success') && !_.isFunction(attrs.success)) {\n              allFunctions = false\n            }\n            if (_.has(attrs, 'error') && !_.isFunction(attrs.error)) {\n              allFunctions = false\n            }\n            if (allFunctions) {\n              // This attrs object looks like it's really an options object,\n              // and there's no other options object, so let's just use it.\n              return this.save(null, attrs)\n            }\n          }\n        }\n  \n        options = _.clone(options) || {}\n        if (options.wait) {\n          current = _.clone(this.attributes)\n        }\n  \n        var setOptions = _.clone(options) || {}\n        if (setOptions.wait) {\n          setOptions.silent = true\n        }\n        var setError\n        setOptions.error = function (model, error) {\n          setError = error\n        }\n        if (attrs && !this.set(attrs, setOptions)) {\n          return Parse.Promise.error(setError)._thenRunCallbacks(options, this)\n        }\n  \n        var model = this\n  \n        // If there is any unsaved child, save it first.\n        model._refreshCache()\n  \n        var unsavedChildren = []\n        var unsavedFiles = []\n        Parse.Object._findUnsavedChildren(model.attributes,\n          unsavedChildren,\n          unsavedFiles)\n        if (unsavedChildren.length + unsavedFiles.length > 0) {\n          return Parse.Object._deepSaveAsync(this.attributes, {\n            useMasterKey: options.useMasterKey,\n            sessionToken: options.sessionToken\n          }).then(function () {\n            return model.save(null, options)\n          }, function (error) {\n            return Parse.Promise.error(error)._thenRunCallbacks(options, model)\n          })\n        }\n  \n        this._startSave()\n        this._saving = (this._saving || 0) + 1\n  \n        this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as()\n        this._allPreviousSaves = this._allPreviousSaves._continueWith(function () {\n          var method = model.id ? 'PUT' : 'POST'\n  \n          var json = model._getSaveJSON()\n  \n          var route = 'classes'\n          var className = model.className\n          if (model.className === '_User' && !model.id) {\n            // Special-case user sign-up.\n            route = 'users'\n            className = null\n          }\n          var request = Parse._request({\n            route: route,\n            className: className,\n            objectId: model.id,\n            method: method,\n            useMasterKey: options.useMasterKey,\n            sessionToken: options.sessionToken,\n            data: json\n          })\n  \n          request = request.then(function (resp, status, xhr) {\n            var serverAttrs = model.parse(resp, status, xhr)\n            if (options.wait) {\n              serverAttrs = _.extend(attrs || {}, serverAttrs)\n            }\n            model._finishSave(serverAttrs)\n            if (options.wait) {\n              model.set(current, setOptions)\n            }\n            return model\n          }, function (error) {\n            model._cancelSave()\n            return Parse.Promise.error(error)\n          })._thenRunCallbacks(options, model)\n  \n          return request\n        })\n        return this._allPreviousSaves\n      },\n  \n      /**\n       * Destroy this model on the server if it was already persisted.\n       * Optimistically removes the model from its collection, if it has one.\n       * If `wait: true` is passed, waits for the server to respond\n       * before removal.\n       *\n       * @param {Object} options A Backbone-style callback object.\n       * Valid options are:<ul>\n       *   <li>wait: Set to true to wait for the server to confirm successful\n       *   deletion of the object before triggering the `destroy` event.\n       *   <li>success: A Backbone-style success callback\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       * @return {Parse.Promise} A promise that is fulfilled when the destroy\n       *     completes.\n       */\n      destroy: function (options) {\n        options = options || {}\n        var model = this\n  \n        var triggerDestroy = function () {\n          model.trigger('destroy', model, model.collection, options)\n        }\n  \n        if (!this.id) {\n          return triggerDestroy()\n        }\n  \n        if (!options.wait) {\n          triggerDestroy()\n        }\n  \n        var request = Parse._request({\n          route: 'classes',\n          className: this.className,\n          objectId: this.id,\n          method: 'DELETE',\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken\n        })\n        return request.then(function () {\n          if (options.wait) {\n            triggerDestroy()\n          }\n          return model\n        })._thenRunCallbacks(options, this)\n      },\n  \n      /**\n       * Converts a response into the hash of attributes to be set on the model.\n       * @ignore\n       */\n      parse: function (resp, status, xhr) {\n        var output = _.clone(resp)\n        _(['createdAt', 'updatedAt']).each(function (key) {\n          if (output[key]) {\n            output[key] = Parse._parseDate(output[key])\n          }\n        })\n        if (!output.updatedAt) {\n          output.updatedAt = output.createdAt\n        }\n        if (status) {\n          this._existed = (status !== 201)\n        }\n        return output\n      },\n  \n      /**\n       * Creates a new model with identical attributes to this one.\n       * @return {Parse.Object}\n       */\n      clone: function () {\n        return new this.constructor(this.attributes)\n      },\n  \n      /**\n       * Returns true if this object has never been saved to Parse.\n       * @return {Boolean}\n       */\n      isNew: function () {\n        return !this.id\n      },\n  \n      /**\n       * Call this method to manually fire a `\"change\"` event for this model and\n       * a `\"change:attribute\"` event for each changed attribute.\n       * Calling this will cause all objects observing the model to update.\n       */\n      change: function (options) {\n        options = options || {}\n        var changing = this._changing\n        this._changing = true\n  \n        // Silent changes become pending changes.\n        var self = this\n        Parse._objectEach(this._silent, function (attr) {\n          self._pending[attr] = true\n        })\n  \n        // Silent changes are triggered.\n        var changes = _.extend({}, options.changes, this._silent)\n        this._silent = {}\n        Parse._objectEach(changes, function (unusedValue, attr) {\n          self.trigger('change:' + attr, self, self.get(attr), options)\n        })\n        if (changing) {\n          return this\n        }\n  \n        // This is to get around lint not letting us make a function in a loop.\n        var deleteChanged = function (value, attr) {\n          if (!self._pending[attr] && !self._silent[attr]) {\n            delete self.changed[attr]\n          }\n        }\n  \n        // Continue firing `\"change\"` events while there are pending changes.\n        while (!_.isEmpty(this._pending)) {\n          this._pending = {}\n          this.trigger('change', this, options)\n          // Pending and silent changes still remain.\n          Parse._objectEach(this.changed, deleteChanged)\n          self._previousAttributes = _.clone(this.attributes)\n        }\n  \n        this._changing = false\n        return this\n      },\n  \n      /**\n       * Returns true if this object was created by the Parse server when the\n       * object might have already been there (e.g. in the case of a Facebook\n       * login)\n       */\n      existed: function () {\n        return this._existed\n      },\n  \n      /**\n       * Determine if the model has changed since the last <code>\"change\"</code>\n       * event.  If you specify an attribute name, determine if that attribute\n       * has changed.\n       * @param {String} attr Optional attribute name\n       * @return {Boolean}\n       */\n      hasChanged: function (attr) {\n        if (!arguments.length) {\n          return !_.isEmpty(this.changed)\n        }\n        return this.changed && _.has(this.changed, attr)\n      },\n  \n      /**\n       * Returns an object containing all the attributes that have changed, or\n       * false if there are no changed attributes. Useful for determining what\n       * parts of a view need to be updated and/or what attributes need to be\n       * persisted to the server. Unset attributes will be set to undefined.\n       * You can also pass an attributes object to diff against the model,\n       * determining if there *would be* a change.\n       */\n      changedAttributes: function (diff) {\n        if (!diff) {\n          return this.hasChanged() ? _.clone(this.changed) : false\n        }\n        var changed = {}\n        var old = this._previousAttributes\n        Parse._objectEach(diff, function (diffVal, attr) {\n          if (!_.isEqual(old[attr], diffVal)) {\n            changed[attr] = diffVal\n          }\n        })\n        return changed\n      },\n  \n      /**\n       * Gets the previous value of an attribute, recorded at the time the last\n       * <code>\"change\"</code> event was fired.\n       * @param {String} attr Name of the attribute to get.\n       */\n      previous: function (attr) {\n        if (!arguments.length || !this._previousAttributes) {\n          return null\n        }\n        return this._previousAttributes[attr]\n      },\n  \n      /**\n       * Gets all of the attributes of the model at the time of the previous\n       * <code>\"change\"</code> event.\n       * @return {Object}\n       */\n      previousAttributes: function () {\n        return _.clone(this._previousAttributes)\n      },\n  \n      /**\n       * Checks if the model is currently in a valid state. It's only possible to\n       * get into an *invalid* state if you're using silent changes.\n       * @return {Boolean}\n       */\n      isValid: function () {\n        return !this.validate(this.attributes)\n      },\n  \n      /**\n       * You should not call this function directly unless you subclass\n       * <code>Parse.Object</code>, in which case you can override this method\n       * to provide additional validation on <code>set</code> and\n       * <code>save</code>.  Your implementation should return\n       *\n       * @param {Object} attrs The current data to validate.\n       * @param {Object} options A Backbone-like options object.\n       * @return {} False if the data is valid.  An error object otherwise.\n       * @see Parse.Object#set\n       */\n      validate: function (attrs, options) {\n        if (_.has(attrs, 'ACL') && !(attrs.ACL instanceof Parse.ACL)) {\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n            'ACL must be a Parse.ACL.')\n        }\n        var correct = true\n        Parse._objectEach(attrs, function (unusedValue, key) {\n          if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\n            correct = false\n          }\n        })\n        if (!correct) {\n          return new Parse.Error(Parse.Error.INVALID_KEY_NAME)\n        }\n        return false\n      },\n  \n      /**\n       * Run validation against a set of incoming attributes, returning `true`\n       * if all is well. If a specific `error` callback has been passed,\n       * call that instead of firing the general `\"error\"` event.\n       */\n      _validate: function (attrs, options) {\n        if (options.silent || !this.validate) {\n          return true\n        }\n        attrs = _.extend({}, this.attributes, attrs)\n        var error = this.validate(attrs, options)\n        if (!error) {\n          return true\n        }\n        if (options && options.error) {\n          options.error(this, error, options)\n        } else {\n          this.trigger('error', this, error, options)\n        }\n        return false\n      },\n  \n      /**\n       * Returns the ACL for this object.\n       * @returns {Parse.ACL} An instance of Parse.ACL.\n       * @see Parse.Object#get\n       */\n      getACL: function () {\n        return this.get('ACL')\n      },\n  \n      /**\n       * Sets the ACL to be used for this object.\n       * @param {Parse.ACL} acl An instance of Parse.ACL.\n       * @param {Object} options Optional Backbone-like options object to be\n       *     passed in to set.\n       * @return {Boolean} Whether the set passed validation.\n       * @see Parse.Object#set\n       */\n      setACL: function (acl, options) {\n        return this.set('ACL', acl, options)\n      }\n  \n    })\n  \n    /**\n     * Returns the appropriate subclass for making new instances of the given\n     * className string.\n     */\n    Parse.Object._getSubclass = function (className) {\n      if (!_.isString(className)) {\n        throw new Error('Parse.Object._getSubclass requires a string argument.')\n      }\n      var ObjectClass = Parse.Object._classMap[className]\n      if (!ObjectClass) {\n        ObjectClass = Parse.Object.extend(className)\n        Parse.Object._classMap[className] = ObjectClass\n      }\n      return ObjectClass\n    }\n  \n    /**\n     * Creates an instance of a subclass of Parse.Object for the given classname.\n     */\n    Parse.Object._create = function (className, attributes, options) {\n      var ObjectClass = Parse.Object._getSubclass(className)\n      return new ObjectClass(attributes, options)\n    }\n  \n    /**\n     * Returns a list of object ids given a list of objects.\n     */\n    Parse.Object._toObjectIdArray = function (list, omitObjectsWithData) {\n      if (list.length === 0) {\n        return Parse.Promise.as(list)\n      }\n  \n      var error\n      var className = list[0].className\n      var objectIds = []\n      for (var i = 0; i < list.length; i++) {\n        var object = list[i]\n        if (className !== object.className) {\n          error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\n            'All objects should be of the same class')\n          return Parse.Promise.error(error)\n        } else if (!object.id) {\n          error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\n            'All objects must have an ID')\n          return Parse.Promise.error(error)\n        } else if (omitObjectsWithData && object._hasData) {\n          continue\n        }\n        objectIds.push(object.id)\n      }\n  \n      return Parse.Promise.as(objectIds)\n    }\n  \n    /**\n     * Updates a list of objects with fetched results.\n     */\n    Parse.Object._updateWithFetchedResults = function (list, fetched, forceFetch) {\n      var fetchedObjectsById = {}\n      Parse._arrayEach(fetched, function (object, i) {\n        fetchedObjectsById[object.id] = object\n      })\n  \n      for (var i = 0; i < list.length; i++) {\n        var object = list[i]\n        var fetchedObject = fetchedObjectsById[object.id]\n        if (!fetchedObject && forceFetch) {\n          var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n            'All objects must exist on the server')\n          return Parse.Promise.error(error)\n        }\n  \n        object._mergeFromObject(fetchedObject)\n      }\n  \n      return Parse.Promise.as(list)\n    }\n  \n    /**\n     * Fetches the objects given in list.  The forceFetch option will fetch all\n     * objects if true and ignore objects with data if false.\n     */\n    Parse.Object._fetchAll = function (list, forceFetch) {\n      if (list.length === 0) {\n        return Parse.Promise.as(list)\n      }\n  \n      var omitObjectsWithData = !forceFetch\n      return Parse.Object._toObjectIdArray(\n        list,\n        omitObjectsWithData\n      ).then(function (objectIds) {\n        var className = list[0].className\n        var query = new Parse.Query(className)\n        query.containedIn('objectId', objectIds)\n        query.limit = objectIds.length\n        return query.find()\n      }).then(function (results) {\n        return Parse.Object._updateWithFetchedResults(\n          list,\n          results,\n          forceFetch\n        )\n      })\n    }\n  \n    // Set up a map of className to class so that we can create new instances of\n    // Parse Objects from JSON automatically.\n    Parse.Object._classMap = {}\n  \n    Parse.Object._extend = Parse._extend\n  \n    /**\n     * Creates a new subclass of Parse.Object for the given Parse class name.\n     *\n     * <p>Every extension of a Parse class will inherit from the most recent\n     * previous extension of that class. When a Parse.Object is automatically\n     * created by parsing JSON, it will use the most recent extension of that\n     * class.</p>\n     *\n     * <p>You should call either:<pre>\n     *     var MyClass = Parse.Object.extend(\"MyClass\", {\n     *         <i>Instance methods</i>,\n     *         initialize: function(attrs, options) {\n     *             this.someInstanceProperty = [],\n     *             <i>Other instance properties</i>\n     *         }\n     *     }, {\n     *         <i>Class properties</i>\n     *     });</pre>\n     * or, for Backbone compatibility:<pre>\n     *     var MyClass = Parse.Object.extend({\n     *         className: \"MyClass\",\n     *         <i>Instance methods</i>,\n     *         initialize: function(attrs, options) {\n     *             this.someInstanceProperty = [],\n     *             <i>Other instance properties</i>\n     *         }\n     *     }, {\n     *         <i>Class properties</i>\n     *     });</pre></p>\n     *\n     * @param {String} className The name of the Parse class backing this model.\n     * @param {Object} protoProps Instance properties to add to instances of the\n     *     class returned from this method.\n     * @param {Object} classProps Class properties to add the class returned from\n     *     this method.\n     * @return {Class} A new subclass of Parse.Object.\n     */\n    Parse.Object.extend = function (className, protoProps, classProps) {\n      // Handle the case with only two args.\n      if (!_.isString(className)) {\n        if (className && _.has(className, 'className')) {\n          return Parse.Object.extend(className.className, className, protoProps)\n        } else {\n          throw new Error(\n            \"Parse.Object.extend's first argument should be the className.\")\n        }\n      }\n  \n      // If someone tries to subclass \"User\", coerce it to the right type.\n      if (className === 'User' && Parse.User._performUserRewrite) {\n        className = '_User'\n      }\n      protoProps = protoProps || {}\n      protoProps.className = className\n  \n      var NewClassObject = null\n      if (_.has(Parse.Object._classMap, className)) {\n        var OldClassObject = Parse.Object._classMap[className]\n        // This new subclass has been told to extend both from \"this\" and from\n        // OldClassObject. This is multiple inheritance, which isn't supported.\n        // For now, let's just pick one.\n        NewClassObject = OldClassObject._extend(protoProps, classProps)\n      } else {\n        NewClassObject = this._extend(protoProps, classProps)\n      }\n      // Extending a subclass should reuse the classname automatically.\n      NewClassObject.extend = function (arg0) {\n        if (_.isString(arg0) || (arg0 && _.has(arg0, 'className'))) {\n          return Parse.Object.extend.apply(NewClassObject, arguments)\n        }\n        var newArguments = [className].concat(Parse._.toArray(arguments))\n        return Parse.Object.extend.apply(NewClassObject, newArguments)\n      }\n  \n      /**\n       * Creates a reference to a subclass of Parse.Object with the given id. This\n       * does not exist on Parse.Object, only on subclasses.\n       *\n       * <p>A shortcut for: <pre>\n       *  var Foo = Parse.Object.extend(\"Foo\")\n       *  var pointerToFoo = new Foo()\n       *  pointerToFoo.id = \"myObjectId\"\n       * </pre>\n       *\n       * @name createWithoutData\n       * @param {String} id The ID of the object to create a reference to.\n       * @return {Parse.Object} A Parse.Object reference.\n       * @function\n       * @memberOf Parse.Object\n       */\n      NewClassObject.createWithoutData = function (id) {\n        var obj = new NewClassObject()\n        obj.id = id\n        return obj\n      }\n  \n      Parse.Object._classMap[className] = NewClassObject\n      return NewClassObject\n    }\n  \n    Parse.Object._findUnsavedChildren = function (object, children, files) {\n      Parse._traverse(object, function (object) {\n        if (object instanceof Parse.Object) {\n          object._refreshCache()\n          if (object.dirty()) {\n            children.push(object)\n          }\n          return\n        }\n  \n        if (object instanceof Parse.File) {\n          if (!object.url()) {\n            files.push(object)\n          }\n          return\n        }\n      })\n    }\n  \n    Parse.Object._canBeSerializedAsValue = function (object) {\n      if (object instanceof Parse.Object) {\n        return !!object.id\n      }\n      if (object instanceof Parse.File) {\n        // Don't recurse indefinitely into files.\n        return true\n      }\n  \n      var canBeSerializedAsValue = true\n  \n      if (_.isArray(object)) {\n        Parse._arrayEach(object, function (child) {\n          if (!Parse.Object._canBeSerializedAsValue(child)) {\n            canBeSerializedAsValue = false\n          }\n        })\n      } else if (_.isObject(object)) {\n        Parse._objectEach(object, function (child) {\n          if (!Parse.Object._canBeSerializedAsValue(child)) {\n            canBeSerializedAsValue = false\n          }\n        })\n      }\n      return canBeSerializedAsValue\n    }\n  \n    /**\n     * @param {Object} object The root object.\n     * @param {Object} options: The only valid option is useMasterKey.\n     */\n    Parse.Object._deepSaveAsync = function (object, options) {\n      var unsavedChildren = []\n      var unsavedFiles = []\n      Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles)\n  \n      var promise = Parse.Promise.as()\n      _.each(unsavedFiles, function (file) {\n        promise = promise.then(function () {\n          return file.save(options)\n        })\n      })\n  \n      var objects = _.uniq(unsavedChildren)\n      var remaining = _.uniq(objects)\n  \n      return promise.then(function () {\n        return Parse.Promise._continueWhile(function () {\n          return remaining.length > 0\n        }, function () {\n          // Gather up all the objects that can be saved in this batch.\n          var batch = []\n          var newRemaining = []\n          Parse._arrayEach(remaining, function (object) {\n            // Limit batches to 20 objects.\n            if (batch.length > 20) {\n              newRemaining.push(object)\n              return\n            }\n  \n            if (object._canBeSerialized()) {\n              batch.push(object)\n            } else {\n              newRemaining.push(object)\n            }\n          })\n          remaining = newRemaining\n  \n          // If we can't save any objects, there must be a circular reference.\n          if (batch.length === 0) {\n            return Parse.Promise.error(\n              new Parse.Error(Parse.Error.OTHER_CAUSE,\n                'Tried to save a batch with a cycle.'))\n          }\n  \n          // Reserve a spot in every object's save queue.\n          var readyToStart = Parse.Promise.when(_.map(batch, function (object) {\n            return object._allPreviousSaves || Parse.Promise.as()\n          }))\n          var batchFinished = new Parse.Promise()\n          Parse._arrayEach(batch, function (object) {\n            object._allPreviousSaves = batchFinished\n          })\n  \n          // Save a single batch, whether previous saves succeeded or failed.\n          return readyToStart._continueWith(function () {\n            return Parse._request({\n              route: 'batch',\n              method: 'POST',\n              useMasterKey: options.useMasterKey,\n              sessionToken: options.sessionToken,\n              data: {\n                requests: _.map(batch, function (object) {\n                  var json = object._getSaveJSON()\n                  var method = 'POST'\n  \n                  var path = '/1/classes/' + object.className\n                  if (object.id) {\n                    path = path + '/' + object.id\n                    method = 'PUT'\n                  }\n  \n                  object._startSave()\n  \n                  return {\n                    method: method,\n                    path: path,\n                    body: json\n                  }\n                })\n              }\n            }).then(function (response, status, xhr) {\n              var error\n              Parse._arrayEach(batch, function (object, i) {\n                if (response[i].success) {\n                  object._finishSave(\n                    object.parse(response[i].success, status, xhr))\n                } else {\n                  error = error || response[i].error\n                  object._cancelSave()\n                }\n              })\n              if (error) {\n                return Parse.Promise.error(\n                  new Parse.Error(error.code, error.error))\n              }\n            }).then(function (results) {\n              batchFinished.resolve(results)\n              return results\n            }, function (error) {\n              batchFinished.reject(error)\n              return Parse.Promise.error(error)\n            })\n          })\n        })\n      }).then(function () {\n        return object\n      })\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Represents a Role on the Parse server. Roles represent groupings of\n     * Users for the purposes of granting permissions (e.g. specifying an ACL\n     * for an Object). Roles are specified by their sets of child users and\n     * child roles, all of which are granted any permissions that the parent\n     * role has.\n     *\n     * <p>Roles must have a name (which cannot be changed after creation of the\n     * role), and must specify an ACL.</p>\n     * @class\n     * A Parse.Role is a local representation of a role persisted to the Parse\n     * cloud.\n     */\n    Parse.Role = Parse.Object.extend('_Role', {\n      // Instance Methods\n  \n      /**\n       * Constructs a new ParseRole with the given name and ACL.\n       *\n       * @param {String} name The name of the Role to create.\n       * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n       */\n      constructor: function (name, acl) {\n        if (_.isString(name) && (acl instanceof Parse.ACL)) {\n          Parse.Object.prototype.constructor.call(this, null, null)\n          this.setName(name)\n          this.setACL(acl)\n        } else {\n          Parse.Object.prototype.constructor.call(this, name, acl)\n        }\n      },\n  \n      /**\n       * Gets the name of the role.  You can alternatively call role.get(\"name\")\n       *\n       * @return {String} the name of the role.\n       */\n      getName: function () {\n        return this.get('name')\n      },\n  \n      /**\n       * Sets the name for a role. This value must be set before the role has\n       * been saved to the server, and cannot be set once the role has been\n       * saved.\n       *\n       * <p>\n       *   A role's name can only contain alphanumeric characters, _, -, and\n       *   spaces.\n       * </p>\n       *\n       * <p>This is equivalent to calling role.set(\"name\", name)</p>\n       *\n       * @param {String} name The name of the role.\n       * @param {Object} options Standard options object with success and error\n       *     callbacks.\n       */\n      setName: function (name, options) {\n        return this.set('name', name, options)\n      },\n  \n      /**\n       * Gets the Parse.Relation for the Parse.Users that are direct\n       * children of this role. These users are granted any privileges that this\n       * role has been granted (e.g. read or write access through ACLs). You can\n       * add or remove users from the role through this relation.\n       *\n       * <p>This is equivalent to calling role.relation(\"users\")</p>\n       *\n       * @return {Parse.Relation} the relation for the users belonging to this\n       *     role.\n       */\n      getUsers: function () {\n        return this.relation('users')\n      },\n  \n      /**\n       * Gets the Parse.Relation for the Parse.Roles that are direct\n       * children of this role. These roles' users are granted any privileges that\n       * this role has been granted (e.g. read or write access through ACLs). You\n       * can add or remove child roles from this role through this relation.\n       *\n       * <p>This is equivalent to calling role.relation(\"roles\")</p>\n       *\n       * @return {Parse.Relation} the relation for the roles belonging to this\n       *     role.\n       */\n      getRoles: function () {\n        return this.relation('roles')\n      },\n  \n      /**\n       * @ignore\n       */\n      validate: function (attrs, options) {\n        if ('name' in attrs && attrs.name !== this.getName()) {\n          var newName = attrs.name\n          if (this.id && this.id !== attrs.objectId) {\n            // Check to see if the objectId being set matches this.id.\n            // This happens during a fetch -- the id is set before calling fetch.\n            // Let the name be set in this case.\n            return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name can only be set before it has been saved.\")\n          }\n          if (!_.isString(newName)) {\n            return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name must be a String.\")\n          }\n          if (!(/^[0-9a-zA-Z\\-_ ]+$/).test(newName)) {\n            return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name can only contain alphanumeric characters, _, -, and spaces.\")\n          }\n        }\n        if (Parse.Object.prototype.validate) {\n          return Parse.Object.prototype.validate.call(this, attrs, options)\n        }\n        return false\n      }\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creates a new instance with the given models and options.  Typically, you\n     * will not call this method directly, but will instead make a subclass using\n     * <code>Parse.Collection.extend</code>.\n     *\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\n     *\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>model: The Parse.Object subclass that this collection contains.\n     *   <li>query: An instance of Parse.Query to use when fetching items.\n     *   <li>comparator: A string property name or function to sort by.\n     * </ul>\n     *\n     * @see Parse.Collection.extend\n     *\n     * @class\n     *\n     * <p>Provides a standard collection class for our sets of models, ordered\n     * or unordered.  For more information, see the\n     * <a href=\"http://documentcloud.github.com/backbone/#Collection\">Backbone\n     * documentation</a>.</p>\n     */\n    Parse.Collection = function (models, options) {\n      options = options || {}\n      if (options.comparator) {\n        this.comparator = options.comparator\n      }\n      if (options.model) {\n        this.model = options.model\n      }\n      if (options.query) {\n        this.query = options.query\n      }\n      this._reset()\n      this.initialize.apply(this, arguments)\n      if (models) {\n        this.reset(models, {silent: true, parse: options.parse})\n      }\n    }\n  \n    // Define the Collection's inheritable methods.\n    _.extend(Parse.Collection.prototype, Parse.Events, {\n      // The default model for a collection is just a Parse.Object.\n      // This should be overridden in most cases.\n  \n      model: Parse.Object,\n  \n      /**\n       * Initialize is an empty function by default. Override it with your own\n       * initialization logic.\n       */\n      initialize: function () {},\n  \n      /**\n       * The JSON representation of a Collection is an array of the\n       * models' attributes.\n       */\n      toJSON: function () {\n        return this.map(function (model) {\n          return model.toJSON()\n        })\n      },\n  \n      /**\n       * Add a model, or list of models to the set. Pass **silent** to avoid\n       * firing the `add` event for every new model.\n       *\n       * @param {Array} models An array of instances of <code>Parse.Object</code>.\n       *\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are:<ul>\n       *   <li>at: The index at which to add the models.\n       *   <li>silent: Set to true to avoid firing the `add` event for every new\n       *   model.\n       * </ul>\n       */\n      add: function (models, options) {\n        var i\n        var index\n        var length\n        var model\n        var cid\n        var id\n        var cids = {}\n        var ids = {}\n        options = options || {}\n        models = _.isArray(models) ? models.slice() : [models]\n  \n        // Begin by turning bare objects into model references, and preventing\n        // invalid models or duplicate models from being added.\n        for (i = 0, length = models.length; i < length; i++) {\n          models[i] = this._prepareModel(models[i], options)\n          model = models[i]\n          if (!model) {\n            throw new Error(\"Can't add an invalid model to a collection\")\n          }\n          cid = model.cid\n          if (cids[cid] || this._byCid[cid]) {\n            throw new Error(\"Duplicate cid: can't add the same model \" +\n              'to a collection twice')\n          }\n          id = model.id\n          if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\n            throw new Error(\"Duplicate id: can't add the same model \" +\n              'to a collection twice')\n          }\n          ids[id] = model\n          cids[cid] = model\n        }\n  \n        // Listen to added models' events, and index models for lookup by\n        // `id` and by `cid`.\n        for (i = 0; i < length; i++) {\n          (model = models[i]).on('all', this._onModelEvent, this)\n          this._byCid[model.cid] = model\n          if (model.id) {\n            this._byId[model.id] = model\n          }\n        }\n  \n        // Insert models into the collection, re-sorting if needed, and triggering\n        // `add` events unless silenced.\n        this.length += length\n        index = Parse._isNullOrUndefined(options.at) ? this.models.length : options.at\n        this.models.splice.apply(this.models, [index, 0].concat(models))\n        if (this.comparator) {\n          this.sort({silent: true})\n        }\n        if (options.silent) {\n          return this\n        }\n        for (i = 0, length = this.models.length; i < length; i++) {\n          model = this.models[i]\n          if (cids[model.cid]) {\n            options.index = i\n            model.trigger('add', model, this, options)\n          }\n        }\n        return this\n      },\n  \n      /**\n       * Remove a model, or a list of models from the set. Pass silent to avoid\n       * firing the <code>remove</code> event for every model removed.\n       *\n       * @param {Array} models The model or list of models to remove from the\n       *   collection.\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are: <ul>\n       *   <li>silent: Set to true to avoid firing the `remove` event.\n       * </ul>\n       */\n      remove: function (models, options) {\n        var i, l, index, model\n        options = options || {}\n        models = _.isArray(models) ? models.slice() : [models]\n        for (i = 0, l = models.length; i < l; i++) {\n          model = this.getByCid(models[i]) || this.get(models[i])\n          if (!model) {\n            continue\n          }\n          delete this._byId[model.id]\n          delete this._byCid[model.cid]\n          index = this.indexOf(model)\n          this.models.splice(index, 1)\n          this.length--\n          if (!options.silent) {\n            options.index = index\n            model.trigger('remove', model, this, options)\n          }\n          this._removeReference(model)\n        }\n        return this\n      },\n  \n      /**\n       * Gets a model from the set by id.\n       * @param {String} id The Parse objectId identifying the Parse.Object to\n       * fetch from this collection.\n       */\n      get: function (id) {\n        return id && this._byId[id.id || id]\n      },\n  \n      /**\n       * Gets a model from the set by client id.\n       * @param {} cid The Backbone collection id identifying the Parse.Object to\n       * fetch from this collection.\n       */\n      getByCid: function (cid) {\n        return cid && this._byCid[cid.cid || cid]\n      },\n  \n      /**\n       * Gets the model at the given index.\n       *\n       * @param {Number} index The index of the model to return.\n       */\n      at: function (index) {\n        return this.models[index]\n      },\n  \n      /**\n       * Forces the collection to re-sort itself. You don't need to call this\n       * under normal circumstances, as the set will maintain sort order as each\n       * item is added.\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are: <ul>\n       *   <li>silent: Set to true to avoid firing the `reset` event.\n       * </ul>\n       */\n      sort: function (options) {\n        options = options || {}\n        if (!this.comparator) {\n          throw new Error('Cannot sort a set without a comparator')\n        }\n        var boundComparator = _.bind(this.comparator, this)\n        if (this.comparator.length === 1) {\n          this.models = this.sortBy(boundComparator)\n        } else {\n          this.models.sort(boundComparator)\n        }\n        if (!options.silent) {\n          this.trigger('reset', this, options)\n        }\n        return this\n      },\n  \n      /**\n       * Plucks an attribute from each model in the collection.\n       * @param {String} attr The attribute to return from each model in the\n       * collection.\n       */\n      pluck: function (attr) {\n        return _.map(this.models, function (model) {\n          return model.get(attr)\n        })\n      },\n  \n      /**\n       * When you have more items than you want to add or remove individually,\n       * you can reset the entire set with a new list of models, without firing\n       * any `add` or `remove` events. Fires `reset` when finished.\n       *\n       * @param {Array} models The model or list of models to remove from the\n       *   collection.\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are: <ul>\n       *   <li>silent: Set to true to avoid firing the `reset` event.\n       * </ul>\n       */\n      reset: function (models, options) {\n        var self = this\n        models = models || []\n        options = options || {}\n        Parse._arrayEach(this.models, function (model) {\n          self._removeReference(model)\n        })\n        this._reset()\n        this.add(models, {silent: true, parse: options.parse})\n        if (!options.silent) {\n          this.trigger('reset', this, options)\n        }\n        return this\n      },\n  \n      /**\n       * Fetches the default set of models for this collection, resetting the\n       * collection when they arrive. If `add: true` is passed, appends the\n       * models to the collection instead of resetting.\n       *\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are:<ul>\n       *   <li>silent: Set to true to avoid firing `add` or `reset` events for\n       *   models fetched by this fetch.\n       *   <li>success: A Backbone-style success callback.\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n       *       this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       */\n      fetch: function (options) {\n        options = _.clone(options) || {}\n        if (options.parse === undefined) {\n          options.parse = true\n        }\n        var collection = this\n        var query = this.query || new Parse.Query(this.model)\n        return query.find({\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken\n        }).then(function (results) {\n          if (options.add) {\n            collection.add(results, options)\n          } else {\n            collection.reset(results, options)\n          }\n          return collection\n        })._thenRunCallbacks(options, this)\n      },\n  \n      /**\n       * Creates a new instance of a model in this collection. Add the model to\n       * the collection immediately, unless `wait: true` is passed, in which case\n       * we wait for the server to agree.\n       *\n       * @param {Parse.Object} model The new model to create and add to the\n       *   collection.\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are:<ul>\n       *   <li>wait: Set to true to wait for the server to confirm creation of the\n       *       model before adding it to the collection.\n       *   <li>silent: Set to true to avoid firing an `add` event.\n       *   <li>success: A Backbone-style success callback.\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n       *       this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       */\n      create: function (model, options) {\n        var coll = this\n        options = options ? _.clone(options) : {}\n        model = this._prepareModel(model, options)\n        if (!model) {\n          return false\n        }\n        if (!options.wait) {\n          coll.add(model, options)\n        }\n        var success = options.success\n        options.success = function (nextModel, resp, xhr) {\n          if (options.wait) {\n            coll.add(nextModel, options)\n          }\n          if (success) {\n            success(nextModel, resp)\n          } else {\n            nextModel.trigger('sync', model, resp, options)\n          }\n        }\n        model.save(null, options)\n        return model\n      },\n  \n      /**\n       * Converts a response into a list of models to be added to the collection.\n       * The default implementation is just to pass it through.\n       * @ignore\n       */\n      parse: function (resp, xhr) {\n        return resp\n      },\n  \n      /**\n       * Proxy to _'s chain. Can't be proxied the same way the rest of the\n       * underscore methods are proxied because it relies on the underscore\n       * constructor.\n       */\n      chain: function () {\n        return _(this.models).chain()\n      },\n  \n      /**\n       * Reset all internal state. Called when the collection is reset.\n       */\n      _reset: function (options) {\n        this.length = 0\n        this.models = []\n        this._byId = {}\n        this._byCid = {}\n      },\n  \n      /**\n       * Prepare a model or hash of attributes to be added to this collection.\n       */\n      _prepareModel: function (model, options) {\n        if (!(model instanceof Parse.Object)) {\n          var attrs = model\n          var ModelConstructor = this.model\n          options.collection = this\n          model = new ModelConstructor(attrs, options)\n          if (!model._validate(model.attributes, options)) {\n            model = false\n          }\n        } else if (!model.collection) {\n          model.collection = this\n        }\n        return model\n      },\n  \n      /**\n       * Internal method to remove a model's ties to a collection.\n       */\n      _removeReference: function (model) {\n        if (this === model.collection) {\n          delete model.collection\n        }\n        model.off('all', this._onModelEvent, this)\n      },\n  \n      /**\n       * Internal method called every time a model in the set fires an event.\n       * Sets need to update their indexes when models change ids. All other\n       * events simply proxy through. \"add\" and \"remove\" events that originate\n       * in other collections are ignored.\n       */\n      _onModelEvent: function (ev, model, collection, options) {\n        if ((ev === 'add' || ev === 'remove') && collection !== this) {\n          return\n        }\n        if (ev === 'destroy') {\n          this.remove(model, options)\n        }\n        if (model && ev === 'change:objectId') {\n          delete this._byId[model.previous('objectId')]\n          this._byId[model.id] = model\n        }\n        this.trigger.apply(this, arguments)\n      }\n  \n    })\n  \n    // Underscore methods that we want to implement on the Collection.\n    var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\n      'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\n      'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\n      'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\n      'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy']\n  \n    // Mix in each Underscore method as a proxy to `Collection#models`.\n    Parse._arrayEach(methods, function (method) {\n      Parse.Collection.prototype[method] = function () {\n        return _[method].apply(_, [this.models].concat(_.toArray(arguments)))\n      }\n    })\n  \n    /**\n     * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\n     *   var MyCollection = Parse.Collection.extend({\n     *     // Instance properties\n     *\n     *     model: MyClass,\n     *     query: MyQuery,\n     *\n     *     getFirst: function() {\n     *       return this.at(0)\n     *     }\n     *   }, {\n     *     // Class properties\n     *\n     *     makeOne: function() {\n     *       return new MyCollection()\n     *     }\n     *   })\n     *\n     *   var collection = new MyCollection()\n     * </pre>\n     *\n     * @function\n     * @param {Object} instanceProps Instance properties for the collection.\n     * @param {Object} classProps Class properies for the collection.\n     * @return {Class} A new subclass of <code>Parse.Collection</code>.\n     */\n    Parse.Collection.extend = Parse._extend\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creating a Parse.View creates its initial element outside of the DOM,\n     * if an existing element is not provided...\n     * @class\n     *\n     * <p>A fork of Backbone.View, provided for your convenience.  If you use this\n     * class, you must also include jQuery, or another library that provides a\n     * jQuery-compatible $ function.  For more information, see the\n     * <a href=\"http://documentcloud.github.com/backbone/#View\">Backbone\n     * documentation</a>.</p>\n     * <p><strong><em>Available in the client SDK only.</em></strong></p>\n     */\n    Parse.View = function (options) {\n      this.cid = _.uniqueId('view')\n      this._configure(options || {})\n      this._ensureElement()\n      this.initialize.apply(this, arguments)\n      this.delegateEvents()\n    }\n  \n    // Cached regex to split keys for `delegate`.\n    var eventSplitter = /^(\\S+)\\s*(.*)$/\n  \n    // List of view options to be merged as properties.\n  \n    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',\n      'className', 'tagName']\n  \n    // Set up all inheritable **Parse.View** properties and methods.\n    _.extend(Parse.View.prototype, Parse.Events, {\n  \n      // The default `tagName` of a View's element is `\"div\"`.\n      tagName: 'div',\n  \n      /**\n       * jQuery delegate for element lookup, scoped to DOM elements within the\n       * current view. This should be prefered to global lookups where possible.\n       */\n      $: function (selector) {\n        return this.$el.find(selector)\n      },\n  \n      /**\n       * Initialize is an empty function by default. Override it with your own\n       * initialization logic.\n       */\n      initialize: function () {},\n  \n      /**\n       * The core function that your view should override, in order\n       * to populate its element (`this.el`), with the appropriate HTML. The\n       * convention is for **render** to always return `this`.\n       */\n      render: function () {\n        return this\n      },\n  \n      /**\n       * Remove this view from the DOM. Note that the view isn't present in the\n       * DOM by default, so calling this method may be a no-op.\n       */\n      remove: function () {\n        this.$el.remove()\n        return this\n      },\n  \n      /**\n       * For small amounts of DOM Elements, where a full-blown template isn't\n       * needed, use **make** to manufacture elements, one at a time.\n       * <pre>\n       *     var el = this.make('li', {'class': 'row'},\n       *                        this.model.escape('title'));</pre>\n       */\n      make: function (tagName, attributes, content) {\n        var el = document.createElement(tagName)\n        if (attributes) {\n          Parse.$(el).attr(attributes)\n        }\n        if (content) {\n          Parse.$(el).html(content)\n        }\n        return el\n      },\n  \n      /**\n       * Changes the view's element (`this.el` property), including event\n       * re-delegation.\n       */\n      setElement: function (element, delegate) {\n        this.$el = Parse.$(element)\n        this.el = this.$el[0]\n        if (delegate !== false) {\n          this.delegateEvents()\n        }\n        return this\n      },\n  \n      /**\n       * Set callbacks.  <code>this.events</code> is a hash of\n       * <pre>\n       * *{\"event selector\": \"callback\"}*\n       *\n       *     {\n       *       'mousedown .title':  'edit',\n       *       'click .button':     'save'\n       *       'click .open':       function(e) { ... }\n       *     }\n       * </pre>\n       * pairs. Callbacks will be bound to the view, with `this` set properly.\n       * Uses event delegation for efficiency.\n       * Omitting the selector binds the event to `this.el`.\n       * This only works for delegate-able events: not `focus`, `blur`, and\n       * not `change`, `submit`, and `reset` in Internet Explorer.\n       */\n      delegateEvents: function (events) {\n        events = events || Parse._getValue(this, 'events')\n        if (!events) {\n          return\n        }\n        this.undelegateEvents()\n        var self = this\n        Parse._objectEach(events, function (method, key) {\n          if (!_.isFunction(method)) {\n            method = self[events[key]]\n          }\n          if (!method) {\n            throw new Error('Event \"' + events[key] + '\" does not exist')\n          }\n          var match = key.match(eventSplitter)\n          var eventName = match[1]\n          var selector = match[2]\n          method = _.bind(method, self)\n          eventName += '.delegateEvents' + self.cid\n          if (selector === '') {\n            self.$el.bind(eventName, method)\n          } else {\n            self.$el.delegate(selector, eventName, method)\n          }\n        })\n      },\n  \n      /**\n       * Clears all callbacks previously bound to the view with `delegateEvents`.\n       * You usually don't need to use this, but may wish to if you have multiple\n       * Backbone views attached to the same DOM element.\n       */\n      undelegateEvents: function () {\n        this.$el.unbind('.delegateEvents' + this.cid)\n      },\n  \n      /**\n       * Performs the initial configuration of a View with a set of options.\n       * Keys with special meaning *(model, collection, id, className)*, are\n       * attached directly to the view.\n       */\n      _configure: function (options) {\n        if (this.options) {\n          options = _.extend({}, this.options, options)\n        }\n        var self = this\n        _.each(viewOptions, function (attr) {\n          if (options[attr]) {\n            self[attr] = options[attr]\n          }\n        })\n        this.options = options\n      },\n  \n      /**\n       * Ensure that the View has a DOM element to render into.\n       * If `this.el` is a string, pass it through `$()`, take the first\n       * matching element, and re-assign it to `el`. Otherwise, create\n       * an element from the `id`, `className` and `tagName` properties.\n       */\n      _ensureElement: function () {\n        if (!this.el) {\n          var attrs = Parse._getValue(this, 'attributes') || {}\n          if (this.id) {\n            attrs.id = this.id\n          }\n          if (this.className) {\n            attrs['class'] = this.className\n          }\n          this.setElement(this.make(this.tagName, attrs), false)\n        } else {\n          this.setElement(this.el, false)\n        }\n      }\n  \n    })\n  \n    /**\n     * @function\n     * @param {Object} instanceProps Instance properties for the view.\n     * @param {Object} classProps Class properies for the view.\n     * @return {Class} A new subclass of <code>Parse.View</code>.\n     */\n    Parse.View.extend = Parse._extend\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * @class\n     *\n     * <p>A Parse.User object is a local representation of a user persisted to the\n     * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n     * same functionality of a Parse.Object, but also extends it with various\n     * user specific methods, like authentication, signing up, and validation of\n     * uniqueness.</p>\n     */\n    Parse.User = Parse.Object.extend('_User', /** @lends Parse.User.prototype */ {\n      // Instance Variables\n      _isCurrentUser: false,\n  \n      // Instance Methods\n  \n      /**\n       * Merges another object's attributes into this object.\n       */\n      _mergeFromObject: function (other) {\n        if (other.getSessionToken()) {\n          this._sessionToken = other.getSessionToken()\n        }\n        Parse.User.__super__._mergeFromObject.call(this, other)\n      },\n  \n      /**\n       * Internal method to handle special fields in a _User response.\n       */\n      _mergeMagicFields: function (attrs) {\n        if (attrs.sessionToken) {\n          this._sessionToken = attrs.sessionToken\n          delete attrs.sessionToken\n        }\n        Parse.User.__super__._mergeMagicFields.call(this, attrs)\n      },\n  \n      /**\n       * Removes null values from authData (which exist temporarily for\n       * unlinking)\n       */\n      _cleanupAuthData: function () {\n        if (!this.isCurrent()) {\n          return\n        }\n        var authData = this.get('authData')\n        if (!authData) {\n          return\n        }\n        Parse._objectEach(this.get('authData'), function (value, key) {\n          if (!authData[key]) {\n            delete authData[key]\n          }\n        })\n      },\n  \n      /**\n       * Synchronizes authData for all providers.\n       */\n      _synchronizeAllAuthData: function () {\n        var authData = this.get('authData')\n        if (!authData) {\n          return\n        }\n  \n        var self = this\n        Parse._objectEach(this.get('authData'), function (value, key) {\n          self._synchronizeAuthData(key)\n        })\n      },\n  \n      /**\n       * Synchronizes auth data for a provider (e.g. puts the access token in the\n       * right place to be used by the Facebook SDK).\n       */\n      _synchronizeAuthData: function (provider) {\n        if (!this.isCurrent()) {\n          return\n        }\n        var authType\n        if (_.isString(provider)) {\n          authType = provider\n          provider = Parse.User._authProviders[authType]\n        } else {\n          authType = provider.getAuthType()\n        }\n        var authData = this.get('authData')\n        if (!authData || !provider) {\n          return\n        }\n        var success = provider.restoreAuthentication(authData[authType])\n        if (!success) {\n          this._unlinkFrom(provider)\n        }\n      },\n  \n      _handleSaveResult: function (makeCurrent) {\n        // Clean up and synchronize the authData object, removing any unset values\n        if (makeCurrent) {\n          this._isCurrentUser = true\n        }\n        this._cleanupAuthData()\n        this._synchronizeAllAuthData()\n        // Don't keep the password around.\n        delete this._serverData.password\n        this._rebuildEstimatedDataForKey('password')\n        this._refreshCache()\n        if (makeCurrent || this.isCurrent()) {\n          Parse.User._saveCurrentUser(this)\n        }\n      },\n  \n      /**\n       * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\n       * call linkWith on the user (even if it doesn't exist yet on the server).\n       */\n      _linkWith: function (provider, options) {\n        var authType\n        if (_.isString(provider)) {\n          authType = provider\n          provider = Parse.User._authProviders[provider]\n        } else {\n          authType = provider.getAuthType()\n        }\n        if (_.has(options, 'authData')) {\n          var authData = this.get('authData') || {}\n          authData[authType] = options.authData\n          this.set('authData', authData)\n  \n          // Overridden so that the user can be made the current user.\n          var newOptions = _.clone(options) || {}\n          newOptions.success = function (model) {\n            model._handleSaveResult(true)\n            if (options.success) {\n              options.success.apply(this, arguments)\n            }\n          }\n          return this.save({'authData': authData}, newOptions)\n        } else {\n          var self = this\n          var promise = new Parse.Promise()\n          provider.authenticate({\n            success: function (provider, result) {\n              self._linkWith(provider, {\n                authData: result,\n                success: options.success,\n                error: options.error\n              }).then(function () {\n                promise.resolve(self)\n              })\n            },\n            error: function (provider, error) {\n              if (options.error) {\n                options.error(self, error)\n              }\n              promise.reject(error)\n            }\n          })\n          return promise\n        }\n      },\n  \n      /**\n       * Unlinks a user from a service.\n       */\n      _unlinkFrom: function (provider, options) {\n        if (_.isString(provider)) {\n          provider = Parse.User._authProviders[provider]\n        }\n        var newOptions = _.clone(options)\n        var self = this\n        newOptions.authData = null\n        newOptions.success = function (model) {\n          self._synchronizeAuthData(provider)\n          if (options.success) {\n            options.success.apply(this, arguments)\n          }\n        }\n        return this._linkWith(provider, newOptions)\n      },\n  \n      /**\n       * Checks whether a user is linked to a service.\n       */\n      _isLinked: function (provider) {\n        var authType\n        if (_.isString(provider)) {\n          authType = provider\n        } else {\n          authType = provider.getAuthType()\n        }\n        var authData = this.get('authData') || {}\n        return !!authData[authType]\n      },\n  \n      /**\n       * Deauthenticates all providers.\n       */\n      _logOutWithAll: function () {\n        var authData = this.get('authData')\n        if (!authData) {\n          return\n        }\n        var self = this\n        Parse._objectEach(this.get('authData'), function (value, key) {\n          self._logOutWith(key)\n        })\n      },\n  \n      /**\n       * Deauthenticates a single provider (e.g. removing access tokens from the\n       * Facebook SDK).\n       */\n      _logOutWith: function (provider) {\n        if (!this.isCurrent()) {\n          return\n        }\n        if (_.isString(provider)) {\n          provider = Parse.User._authProviders[provider]\n        }\n        if (provider && provider.deauthenticate) {\n          provider.deauthenticate()\n        }\n      },\n  \n      /**\n       * Signs up a new user. You should call this instead of save for\n       * new Parse.Users. This will create a new Parse.User on the server, and\n       * also persist the session on disk so that you can access the user using\n       * <code>current</code>.\n       *\n       * <p>A username and password must be set before calling signUp.</p>\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {Object} attrs Extra fields to set on the new user, or null.\n       * @param {Object} options A Backbone-style options object.\n       * @return {Parse.Promise} A promise that is fulfilled when the signup\n       *     finishes.\n       * @see Parse.User.signUp\n       */\n      signUp: function (attrs, options) {\n        var error\n        options = options || {}\n  \n        var username = (attrs && attrs.username) || this.get('username')\n        if (!username || (username === '')) {\n          error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            'Cannot sign up user with an empty name.')\n          if (options && options.error) {\n            options.error(this, error)\n          }\n          return Parse.Promise.error(error)\n        }\n  \n        var password = (attrs && attrs.password) || this.get('password')\n        if (!password || (password === '')) {\n          error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            'Cannot sign up user with an empty password.')\n          if (options && options.error) {\n            options.error(this, error)\n          }\n          return Parse.Promise.error(error)\n        }\n  \n        // Overridden so that the user can be made the current user.\n        var newOptions = _.clone(options)\n        newOptions.success = function (model) {\n          model._handleSaveResult(Parse.User._canUseCurrentUser())\n          if (options.success) {\n            options.success.apply(this, arguments)\n          }\n        }\n        return this.save(attrs, newOptions)\n      },\n  \n      /**\n       * Logs in a Parse.User. On success, this saves the session to localStorage,\n       * so you can retrieve the currently logged in user using\n       * <code>current</code>.\n       *\n       * <p>A username and password must be set before calling logIn.</p>\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {Object} options A Backbone-style options object.\n       * @see Parse.User.logIn\n       * @return {Parse.Promise} A promise that is fulfilled with the user when\n       *     the login is complete.\n       */\n      logIn: function (options) {\n        if (!Parse.User._canUseCurrentUser()) {\n          throw new Error(\n            'It is not possible to log in on a server environment.'\n          )\n        }\n        var model = this\n        options = options || {}\n        var request = Parse._request({\n          route: 'login',\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          data: this.toJSON()\n        })\n        return request.then(function (resp, status, xhr) {\n          var serverAttrs = model.parse(resp, status, xhr)\n          model._finishFetch(serverAttrs)\n          model._handleSaveResult(true)\n          return model\n        })._thenRunCallbacks(options, this)\n      },\n  \n      /**\n       * @see Parse.Object#save\n       */\n      save: function (arg1, arg2, arg3) {\n        var attrs, options\n        if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\n          attrs = arg1\n          options = arg2\n        } else {\n          attrs = {}\n          attrs[arg1] = arg2\n          options = arg3\n        }\n        options = options || {}\n  \n        var newOptions = _.clone(options)\n        newOptions.success = function (model) {\n          model._handleSaveResult(false)\n          if (options.success) {\n            options.success.apply(this, arguments)\n          }\n        }\n        return Parse.Object.prototype.save.call(this, attrs, newOptions)\n      },\n  \n      /**\n       * @see Parse.Object#fetch\n       */\n      fetch: function (options) {\n        var newOptions = options ? _.clone(options) : {}\n        newOptions.success = function (model) {\n          model._handleSaveResult(false)\n          if (options && options.success) {\n            options.success.apply(this, arguments)\n          }\n        }\n        return Parse.Object.prototype.fetch.call(this, newOptions)\n      },\n  \n      /**\n       * Returns true if <code>current</code> would return this user.\n       * @see Parse.User#current\n       */\n      isCurrent: function () {\n        return this._isCurrentUser\n      },\n  \n      /**\n       * Returns get(\"username\").\n       * @return {String}\n       * @see Parse.Object#get\n       */\n      getUsername: function () {\n        return this.get('username')\n      },\n  \n      /**\n       * Calls set(\"username\", username, options) and returns the result.\n       * @param {String} username\n       * @param {Object} options A Backbone-style options object.\n       * @return {Boolean}\n       * @see Parse.Object.set\n       */\n      setUsername: function (username, options) {\n        return this.set('username', username, options)\n      },\n  \n      /**\n       * Calls set(\"password\", password, options) and returns the result.\n       * @param {String} password\n       * @param {Object} options A Backbone-style options object.\n       * @return {Boolean}\n       * @see Parse.Object.set\n       */\n      setPassword: function (password, options) {\n        return this.set('password', password, options)\n      },\n  \n      /**\n       * Returns get(\"email\").\n       * @return {String}\n       * @see Parse.Object#get\n       */\n      getEmail: function () {\n        return this.get('email')\n      },\n  \n      /**\n       * Calls set(\"email\", email, options) and returns the result.\n       * @param {String} email\n       * @param {Object} options A Backbone-style options object.\n       * @return {Boolean}\n       * @see Parse.Object.set\n       */\n      setEmail: function (email, options) {\n        return this.set('email', email, options)\n      },\n  \n      /**\n       * Checks whether this user is the current user and has been authenticated.\n       * @return (Boolean) whether this user is the current user and is logged in.\n       */\n      authenticated: function () {\n        return !!this._sessionToken &&\n        (Parse.User.current() && Parse.User.current().id === this.id)\n      },\n  \n      /**\n       * Returns the session token for this user, if the user has been logged in,\n       * or if it is the result of a query with the master key. Otherwise, returns\n       * undefined.\n       * @return {String} the session token, or undefined\n       */\n      getSessionToken: function () {\n        return this._sessionToken\n      },\n  \n      /**\n       * Request a revocable session token to replace the older style of token.\n       * @param {Object} options A Backbone-style options object.\n       *\n       * @return {Parse.Promise} A promise that is resolved when the replacement\n       *   token has been fetched.\n       */\n      _upgradeToRevocableSession: function (options) {\n        options = options || {}\n        if (!Parse.User.current()) {\n          return Parse.Promise.as()._thenRunCallbacks(options)\n        }\n        var currentSession = Parse.User.current().getSessionToken()\n        if (Parse.Session._isRevocable(currentSession)) {\n          return Parse.Promise.as()._thenRunCallbacks(options)\n        }\n        return Parse._request({\n          route: 'upgradeToRevocableSession',\n          method: 'POST',\n          useMasterKey: options.useMasterKey,\n          sessionToken: currentSession\n        }).then(function (result) {\n          var session = new Parse.Session()\n          session._finishFetch(result)\n          var currentUser = Parse.User.current()\n          currentUser._sessionToken = session.getSessionToken()\n          Parse.User._saveCurrentUser(currentUser)\n        })._thenRunCallbacks(options)\n      }\n  \n    }, /** @lends Parse.User */ {\n      // Class Variables\n  \n      // The currently logged-in user.\n      _currentUser: null,\n  \n      // Whether currentUser is known to match the serialized version on disk.\n      // This is useful for saving a localstorage check if you try to load\n      // _currentUser frequently while there is none stored.\n      _currentUserMatchesDisk: false,\n  \n      // The localStorage key suffix that the current user is stored under.\n      _CURRENT_USER_KEY: 'currentUser',\n  \n      // The mapping of auth provider names to actual providers\n      _authProviders: {},\n  \n      // Whether to rewrite className User to _User\n      _performUserRewrite: true,\n  \n      // Whether to send a Revocable Session header\n      _isRevocableSessionEnabled: false,\n  \n      // Whether to enable a memory-unsafe current user in node.js\n      _enableUnsafeCurrentUser: false,\n  \n      // Class Methods\n  \n      /**\n       * Signs up a new user with a username (or email) and password.\n       * This will create a new Parse.User on the server, and also persist the\n       * session in localStorage so that you can access the user using\n       * {@link #current}.\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {String} username The username (or email) to sign up with.\n       * @param {String} password The password to sign up with.\n       * @param {Object} attrs Extra fields to set on the new user.\n       * @param {Object} options A Backbone-style options object.\n       * @return {Parse.Promise} A promise that is fulfilled with the user when\n       *     the signup completes.\n       * @see Parse.User#signUp\n       */\n      signUp: function (username, password, attrs, options) {\n        attrs = attrs || {}\n        attrs.username = username\n        attrs.password = password\n        var user = Parse.Object._create('_User')\n        return user.signUp(attrs, options)\n      },\n  \n      /**\n       * Logs in a user with a username (or email) and password. On success, this\n       * saves the session to disk, so you can retrieve the currently logged in\n       * user using <code>current</code>.\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {String} username The username (or email) to log in with.\n       * @param {String} password The password to log in with.\n       * @param {Object} options A Backbone-style options object.\n       * @return {Parse.Promise} A promise that is fulfilled with the user when\n       *     the login completes.\n       * @see Parse.User#logIn\n       */\n      logIn: function (username, password, options) {\n        var user = Parse.Object._create('_User')\n        user._finishFetch({ username: username, password: password })\n        return user.logIn(options)\n      },\n  \n      /**\n       * Logs in a user with a session token. On success, this saves the session\n       * to disk, so you can retrieve the currently logged in user using\n       * <code>current</code>.\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {String} sessionToken The sessionToken to log in with.\n       * @param {Object} options A Backbone-style options object.\n       * @return {Parse.Promise} A promise that is fulfilled with the user when\n       *     the login completes.\n       */\n      become: function (sessionToken, options) {\n        if (!Parse.User._canUseCurrentUser()) {\n          throw new Error(\n            'It is not secure to become a user on a node.js server environment.'\n          )\n        }\n        options = options || {}\n  \n        var user = Parse.Object._create('_User')\n        return Parse._request({\n          route: 'users',\n          className: 'me',\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          sessionToken: sessionToken\n        }).then(function (resp, status, xhr) {\n          var serverAttrs = user.parse(resp, status, xhr)\n          user._finishFetch(serverAttrs)\n          user._handleSaveResult(true)\n          return user\n        })._thenRunCallbacks(options, user)\n      },\n  \n      /**\n       * Logs out the currently logged in user session. This will remove the\n       * session from disk, log out of linked services, and future calls to\n       * <code>current</code> will return <code>null</code>.\n       * @return {Parse.Promise} A promise that is resolved when the session is\n       *   destroyed on the server.\n       */\n      logOut: function () {\n        if (!Parse.User._canUseCurrentUser()) {\n          throw new Error(\n            'There is no current user user on a node.js server environment.'\n          )\n        }\n        return Parse.User._currentAsync().then(function (currentUser) {\n          var promise = Parse.Storage.removeItemAsync(\n            Parse._getParsePath(Parse.User._CURRENT_USER_KEY))\n  \n          if (currentUser !== null) {\n            var currentSession = currentUser.getSessionToken()\n            if (Parse.Session._isRevocable(currentSession)) {\n              promise.then(function () {\n                return Parse._request({\n                  route: 'logout',\n                  method: 'POST',\n                  sessionToken: currentSession\n                })\n              })\n            }\n            currentUser._logOutWithAll()\n            currentUser._isCurrentUser = false\n          }\n          Parse.User._currentUserMatchesDisk = true\n          Parse.User._currentUser = null\n  \n          return promise\n        })\n      },\n  \n      /**\n       * Requests a password reset email to be sent to the specified email address\n       * associated with the user account. This email allows the user to securely\n       * reset their password on the Parse site.\n       *\n       * <p>Calls options.success or options.error on completion.</p>\n       *\n       * @param {String} email The email address associated with the user that\n       *     forgot their password.\n       * @param {Object} options A Backbone-style options object.\n       */\n      requestPasswordReset: function (email, options) {\n        options = options || {}\n        var request = Parse._request({\n          route: 'requestPasswordReset',\n          method: 'POST',\n          useMasterKey: options.useMasterKey,\n          data: { email: email }\n        })\n        return request._thenRunCallbacks(options)\n      },\n  \n      /**\n       * Retrieves the currently logged in ParseUser with a valid session,\n       * either from memory or localStorage, if necessary.\n       * @return {Parse.Object} The currently logged in Parse.User.\n       */\n      current: function () {\n        if (!Parse.User._canUseCurrentUser()) {\n          throw new Error(\n            'There is no current user user on a node.js server environment.'\n          )\n        }\n        if (Parse.Storage.async) {\n          // We can't return the current user synchronously\n          Parse.User._currentAsync()\n          return Parse.User._currentUser\n        }\n  \n        if (Parse.User._currentUser) {\n          return Parse.User._currentUser\n        }\n  \n        if (Parse.User._currentUserMatchesDisk) {\n          return Parse.User._currentUser\n        }\n  \n        // Load the user from local storage.\n        Parse.User._currentUserMatchesDisk = true\n  \n        var userData = Parse.Storage.getItem(Parse._getParsePath(\n          Parse.User._CURRENT_USER_KEY))\n        if (!userData) {\n          return null\n        }\n        Parse.User._currentUser = Parse.Object._create('_User')\n        Parse.User._currentUser._isCurrentUser = true\n  \n        var json = JSON.parse(userData)\n        Parse.User._currentUser.id = json._id\n        delete json._id\n        Parse.User._currentUser._sessionToken = json._sessionToken\n        delete json._sessionToken\n        Parse.User._currentUser._finishFetch(json)\n  \n        Parse.User._currentUser._synchronizeAllAuthData()\n        Parse.User._currentUser._refreshCache()\n        Parse.User._currentUser._opSetQueue = [{}]\n        return Parse.User._currentUser\n      },\n  \n      /**\n       * Retrieves the currently logged in ParseUser from asynchronous Storage.\n       * @return {Parse.Promise} A Promise that is resolved with the currently\n       *   logged in Parse User\n       */\n      _currentAsync: function () {\n        if (Parse.User._currentUser) {\n          return Parse.Promise.as(Parse.User._currentUser)\n        }\n  \n        if (Parse.User._currentUserMatchesDisk) {\n          return Parse.Promise.as(Parse.User._currentUser)\n        }\n  \n        // Load the user from Storage\n        return Parse.Storage.getItemAsync(Parse._getParsePath(\n          Parse.User._CURRENT_USER_KEY))\n          .then(function (userData) {\n            if (!userData) {\n              return null\n            }\n            Parse.User._currentUser = Parse.Object._create('_User')\n            Parse.User._currentUser._isCurrentUser = true\n  \n            var json = JSON.parse(userData)\n            Parse.User._currentUser.id = json._id\n            delete json._id\n            Parse.User._currentUser._sessionToken = json._sessionToken\n            delete json._sessionToken\n            Parse.User._currentUser._finishFetch(json)\n  \n            Parse.User._currentUser._synchronizeAllAuthData()\n            Parse.User._currentUser._refreshCache()\n            Parse.User._currentUser._opSetQueue = [{}]\n            return Parse.User._currentUser\n          })\n      },\n  \n      /**\n       * Allow someone to define a custom User class without className\n       * being rewritten to _User. The default behavior is to rewrite\n       * User to _User for legacy reasons. This allows developers to\n       * override that behavior.\n       *\n       * @param {Boolean} isAllowed Whether or not to allow custom User class\n       */\n      allowCustomUserClass: function (isAllowed) {\n        this._performUserRewrite = !isAllowed\n      },\n  \n      /**\n       * Allow a legacy application to start using revocable sessions. If the\n       * current session token is not revocable, a request will be made for a new,\n       * revocable session.\n       * It is not necessary to call this method from cloud code unless you are\n       * handling user signup or login from the server side. In a cloud code call,\n       * this function will not attempt to upgrade the current token.\n       * @param {Object} options A Backbone-style options object.\n       *\n       * @return {Parse.Promise} A promise that is resolved when the process has\n       *   completed. If a replacement session token is requested, the promise\n       *   will be resolved after a new token has been fetched.\n       */\n      enableRevocableSession: function (options) {\n        options = options || {}\n        Parse.User._isRevocableSessionEnabled = true\n        if (Parse.User._canUseCurrentUser() && Parse.User.current()) {\n          return Parse.User.current()._upgradeToRevocableSession(options)\n        }\n        return Parse.Promise.as()._thenRunCallbacks(options)\n      },\n  \n      /**\n       *\n       */\n      enableUnsafeCurrentUser: function () {\n        Parse.User._enableUnsafeCurrentUser = true\n      },\n  \n      _canUseCurrentUser: function () {\n        return !Parse._isNode || Parse.User._enableUnsafeCurrentUser\n      },\n  \n      /**\n       * Persists a user as currentUser to localStorage, and into the singleton.\n       */\n      _saveCurrentUser: function (user) {\n        if (Parse.User._currentUser !== null &&\n          Parse.User._currentUser !== user) {\n          Parse.User.logOut()\n        }\n        user._isCurrentUser = true\n        Parse.User._currentUser = user\n        Parse.User._currentUserMatchesDisk = true\n  \n        var json = user.toJSON()\n        json._id = user.id\n        json._sessionToken = user._sessionToken\n        if (Parse.Storage.async) {\n          Parse.Storage.setItemAsync(\n            Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\n            JSON.stringify(json))\n        } else {\n          Parse.Storage.setItem(\n            Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\n            JSON.stringify(json))\n        }\n      },\n  \n      _registerAuthenticationProvider: function (provider) {\n        Parse.User._authProviders[provider.getAuthType()] = provider\n        // Synchronize the current user with the auth provider.\n        if (Parse.User.current()) {\n          Parse.User.current()._synchronizeAuthData(provider.getAuthType())\n        }\n      },\n  \n      _logInWith: function (provider, options) {\n        var user = Parse.Object._create('_User')\n        return user._linkWith(provider, options)\n      }\n  \n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n  \n    /**\n     * @class\n     *\n     * <p>A Parse.Session object is a local representation of a revocable session.\n     * This class is a subclass of a Parse.Object, and retains the same\n     * functionality of a Parse.Object.</p>\n     */\n    Parse.Session = Parse.Object.extend('_Session', {\n      /**\n       * Returns the session token string.\n       * @return {String}\n       */\n      getSessionToken: function () {\n        return this._sessionToken\n      },\n  \n      /**\n       * Internal method to handle special fields in a _Session response.\n       */\n      _mergeMagicFields: function (attrs) {\n        if (attrs.sessionToken) {\n          this._sessionToken = attrs.sessionToken\n          delete attrs.sessionToken\n        }\n        Parse.Session.__super__._mergeMagicFields.call(this, attrs)\n      }\n    }, /** @lends Parse.Session */ {\n  \n      // Throw an error when modifying these read-only fields\n      readOnlyAttributes: {\n        createdWith: true,\n        expiresAt: true,\n        installationId: true,\n        restricted: true,\n        sessionToken: true,\n        user: true\n      },\n  \n      /**\n       * Retrieves the Session object for the currently logged in session.\n       * @return {Parse.Promise} A promise that is resolved with the Parse.Session\n       *   object after it has been fetched.\n       */\n      current: function (options) {\n        options = options || {}\n  \n        var session = Parse.Object._create('_Session')\n        var currentToken = Parse.User.current().getSessionToken()\n        return Parse._request({\n          route: 'sessions',\n          className: 'me',\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          sessionToken: currentToken\n        }).then(function (resp, status, xhr) {\n          var serverAttrs = session.parse(resp, status, xhr)\n          session._finishFetch(serverAttrs)\n          return session\n        })._thenRunCallbacks(options, session)\n      },\n  \n      /**\n       * Determines whether a session token is revocable.\n       * @return {Boolean}\n       */\n      _isRevocable: function (token) {\n        return token.indexOf('r:') > -1\n      },\n  \n      /**\n       * Determines whether the current session token is revocable.\n       * This method is useful for migrating Express.js or Node.js web apps to\n       * use revocable sessions. If you are migrating an app that uses the Parse\n       * SDK in the browser only, please use Parse.User.enableRevocableSession()\n       * instead, so that sessions can be automatically upgraded.\n       * @return {Boolean}\n       */\n      isCurrentSessionRevocable: function () {\n        if (Parse.User.current() !== null) {\n          return Parse.Session._isRevocable(\n            Parse.User.current().getSessionToken()\n          )\n        }\n      }\n    })\n  })(this)\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Creates a new parse Parse.Query for the given Parse.Object subclass.\n     * @param objectClass -\n     *   An instance of a subclass of Parse.Object, or a Parse className string.\n     * @class\n     *\n     * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n     * most common use case is finding all objects that match a query through the\n     * <code>find</code> method. For example, this sample code fetches all objects\n     * of class <code>MyClass</code>. It calls a different function depending on\n     * whether the fetch succeeded or not.\n     *\n     * <pre>\n     * var query = new Parse.Query(MyClass)\n     * query.find({\n     *   success: function(results) {\n     *     // results is an array of Parse.Object.\n     *   },\n     *\n     *   error: function(error) {\n     *     // error is an instance of Parse.Error.\n     *   }\n     * });</pre></p>\n     *\n     * <p>A Parse.Query can also be used to retrieve a single object whose id is\n     * known, through the get method. For example, this sample code fetches an\n     * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\n     * different function depending on whether the fetch succeeded or not.\n     *\n     * <pre>\n     * var query = new Parse.Query(MyClass)\n     * query.get(myId, {\n     *   success: function(object) {\n     *     // object is an instance of Parse.Object.\n     *   },\n     *\n     *   error: function(object, error) {\n     *     // error is an instance of Parse.Error.\n     *   }\n     * });</pre></p>\n     *\n     * <p>A Parse.Query can also be used to count the number of objects that match\n     * the query without retrieving all of those objects. For example, this\n     * sample code counts the number of objects of the class <code>MyClass</code>\n     * <pre>\n     * var query = new Parse.Query(MyClass)\n     * query.count({\n     *   success: function(number) {\n     *     // There are number instances of MyClass.\n     *   },\n     *\n     *   error: function(error) {\n     *     // error is an instance of Parse.Error.\n     *   }\n     * });</pre></p>\n     */\n    Parse.Query = function (objectClass) {\n      if (_.isString(objectClass)) {\n        objectClass = Parse.Object._getSubclass(objectClass)\n      }\n  \n      this.objectClass = objectClass\n  \n      this.className = objectClass.prototype.className\n  \n      this._where = {}\n      this._include = []\n      this._limit = -1 // negative limit means, do not send a limit\n      this._skip = 0\n      this._extraOptions = {}\n    }\n  \n    /**\n     * Constructs a Parse.Query that is the OR of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an or of the query1, query2, and\n     * query3.\n     * @param {...Parse.Query} var_args The list of queries to OR.\n     * @return {Parse.Query} The query that is the OR of the passed in queries.\n     */\n    Parse.Query.or = function () {\n      var queries = _.toArray(arguments)\n      var className = null\n      Parse._arrayEach(queries, function (q) {\n        if (_.isNull(className)) {\n          className = q.className\n        }\n  \n        if (className !== q.className) {\n          throw new Error('All queries must be for the same class')\n        }\n      })\n      var query = new Parse.Query(className)\n      query._orQuery(queries)\n      return query\n    }\n  \n    Parse.Query.prototype = {\n      /**\n       * Constructs a Parse.Object whose id is already known by fetching data from\n       * the server.  Either options.success or options.error is called when the\n       * find completes.\n       *\n       * @param {String} objectId The id of the object to be fetched.\n       * @param {Object} options A Backbone-style options object.\n       * Valid options are:<ul>\n       *   <li>success: A Backbone-style success callback\n       *   <li>error: An Backbone-style error callback.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       */\n      get: function (objectId, options) {\n        var self = this\n        self.equalTo('objectId', objectId)\n  \n        var firstOptions = {}\n        if (options && _.has(options, 'useMasterKey')) {\n          firstOptions = { useMasterKey: options.useMasterKey }\n        }\n        if (options && _.has(options, 'sessionToken')) {\n          firstOptions.sessionToken = options.sessionToken\n        }\n  \n        return self.first(firstOptions).then(function (response) {\n          if (response) {\n            return response\n          }\n  \n          var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n            'Object not found.')\n          return Parse.Promise.error(errorObject)\n        })._thenRunCallbacks(options, null)\n      },\n  \n      /**\n       * Returns a JSON representation of this query.\n       * @return {Object} The JSON representation of the query.\n       */\n      toJSON: function () {\n        var params = {\n          where: this._where\n        }\n  \n        if (this._include.length > 0) {\n          params.include = this._include.join(',')\n        }\n        if (this._select) {\n          params.keys = this._select.join(',')\n        }\n        if (this._limit >= 0) {\n          params.limit = this._limit\n        }\n        if (this._skip > 0) {\n          params.skip = this._skip\n        }\n        if (this._order !== undefined) {\n          params.order = this._order.join(',')\n        }\n  \n        Parse._objectEach(this._extraOptions, function (v, k) {\n          params[k] = v\n        })\n  \n        return params\n      },\n  \n      /**\n       * Retrieves a list of ParseObjects that satisfy this query.\n       * Either options.success or options.error is called when the find\n       * completes.\n       *\n       * @param {Object} options A Backbone-style options object. Valid options\n       * are:<ul>\n       *   <li>success: Function to call when the find completes successfully.\n       *   <li>error: Function to call when the find fails.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       *\n       * @return {Parse.Promise} A promise that is resolved with the results when\n       * the query completes.\n       */\n      find: function (options) {\n        var self = this\n        options = options || {}\n  \n        var request = Parse._request({\n          route: 'classes',\n          className: this.className,\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken,\n          data: this.toJSON()\n        })\n  \n        return request.then(function (response) {\n          return _.map(response.results, function (json) {\n            var obj\n            if (response.className) {\n              obj = new Parse.Object(response.className)\n            } else {\n              var ObjectConstructor = self.objectClass\n              obj = new ObjectConstructor()\n            }\n            obj._finishFetch(json, true)\n            return obj\n          })\n        })._thenRunCallbacks(options)\n      },\n  \n      /**\n       * Counts the number of objects that match this query.\n       * Either options.success or options.error is called when the count\n       * completes.\n       *\n       * @param {Object} options A Backbone-style options object. Valid options\n       * are:<ul>\n       *   <li>success: Function to call when the count completes successfully.\n       *   <li>error: Function to call when the find fails.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       *\n       * @return {Parse.Promise} A promise that is resolved with the count when\n       * the query completes.\n       */\n      count: function (options) {\n        var self = this\n        options = options || {}\n  \n        var params = this.toJSON()\n        params.limit = 0\n        params.count = 1\n        var request = Parse._request({\n          route: 'classes',\n          className: self.className,\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken,\n          data: params\n        })\n  \n        return request.then(function (response) {\n          return response.count\n        })._thenRunCallbacks(options)\n      },\n  \n      /**\n       * Retrieves at most one Parse.Object that satisfies this query.\n       *\n       * Either options.success or options.error is called when it completes.\n       * success is passed the object if there is one. otherwise, undefined.\n       *\n       * @param {Object} options A Backbone-style options object. Valid options\n       * are:<ul>\n       *   <li>success: Function to call when the find completes successfully.\n       *   <li>error: Function to call when the find fails.\n       *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n       *     be used for this request.\n       *   <li>sessionToken: A valid session token, used for making a request on\n       *       behalf of a specific user.\n       * </ul>\n       *\n       * @return {Parse.Promise} A promise that is resolved with the object when\n       * the query completes.\n       */\n      first: function (options) {\n        var self = this\n        options = options || {}\n  \n        var params = this.toJSON()\n        params.limit = 1\n        var request = Parse._request({\n          route: 'classes',\n          className: this.className,\n          method: 'GET',\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken,\n          data: params\n        })\n  \n        return request.then(function (response) {\n          return _.map(response.results, function (json) {\n            var obj\n            if (response.className) {\n              obj = new Parse.Object(response.className)\n            } else {\n              var ObjectConstructor = self.objectClass\n              obj = new ObjectConstructor()\n            }\n            obj._finishFetch(json, true)\n            return obj\n          })[0]\n        })._thenRunCallbacks(options)\n      },\n  \n      /**\n       * Returns a new instance of Parse.Collection backed by this query.\n       * @param {Array} items An array of instances of <code>Parse.Object</code>\n       *     with which to start this Collection.\n       * @param {Object} options An optional object with Backbone-style options.\n       * Valid options are:<ul>\n       *   <li>model: The Parse.Object subclass that this collection contains.\n       *   <li>query: An instance of Parse.Query to use when fetching items.\n       *   <li>comparator: A string property name or function to sort by.\n       * </ul>\n       * @return {Parse.Collection}\n       */\n      collection: function (items, options) {\n        options = options || {}\n        return new Parse.Collection(items, _.extend(options, {\n          model: this.objectClass,\n          query: this\n        }))\n      },\n  \n      /**\n       * Sets the number of results to skip before returning any results.\n       * This is useful for pagination.\n       * Default is to skip zero results.\n       * @param {Number} n the number of results to skip.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      skip: function (n) {\n        this._skip = n\n        return this\n      },\n  \n      /**\n       * Sets the limit of the number of results to return. The default limit is\n       * 100, with a maximum of 1000 results being returned at a time.\n       * @param {Number} n the number of results to limit to.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      limit: function (n) {\n        this._limit = n\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be equal to the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that the Parse.Object must contain.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      equalTo: function (key, value) {\n        if (_.isUndefined(value)) {\n          return this.doesNotExist(key)\n        }\n  \n        this._where[key] = Parse._encode(value)\n        return this\n      },\n  \n      /**\n       * Helper for condition queries\n       */\n      _addCondition: function (key, condition, value) {\n        // Check if we already have a condition\n        if (!this._where[key]) {\n          this._where[key] = {}\n        }\n        this._where[key][condition] = Parse._encode(value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be not equal to the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that must not be equalled.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      notEqualTo: function (key, value) {\n        this._addCondition(key, '$ne', value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be less than the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that provides an upper bound.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      lessThan: function (key, value) {\n        this._addCondition(key, '$lt', value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be greater than the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that provides an lower bound.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      greaterThan: function (key, value) {\n        this._addCondition(key, '$gt', value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be less than or equal to the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that provides an upper bound.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      lessThanOrEqualTo: function (key, value) {\n        this._addCondition(key, '$lte', value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be greater than or equal to the provided value.\n       * @param {String} key The key to check.\n       * @param value The value that provides an lower bound.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      greaterThanOrEqualTo: function (key, value) {\n        this._addCondition(key, '$gte', value)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * be contained in the provided list of values.\n       * @param {String} key The key to check.\n       * @param {Array} values The values that will match.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      containedIn: function (key, values) {\n        this._addCondition(key, '$in', values)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * not be contained in the provided list of values.\n       * @param {String} key The key to check.\n       * @param {Array} values The values that will not match.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      notContainedIn: function (key, values) {\n        this._addCondition(key, '$nin', values)\n        return this\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's value to\n       * contain each one of the provided list of values.\n       * @param {String} key The key to check.  This key's value must be an array.\n       * @param {Array} values The values that will match.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      containsAll: function (key, values) {\n        this._addCondition(key, '$all', values)\n        return this\n      },\n  \n      /**\n       * Add a constraint for finding objects that contain the given key.\n       * @param {String} key The key that should exist.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      exists: function (key) {\n        this._addCondition(key, '$exists', true)\n        return this\n      },\n  \n      /**\n       * Add a constraint for finding objects that do not contain a given key.\n       * @param {String} key The key that should not exist\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      doesNotExist: function (key) {\n        this._addCondition(key, '$exists', false)\n        return this\n      },\n  \n      /**\n       * Add a regular expression constraint for finding string values that match\n       * the provided regular expression.\n       * This may be slow for large datasets.\n       * @param {String} key The key that the string to match is stored in.\n       * @param {RegExp} regex The regular expression pattern to match.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      matches: function (key, regex, modifiers) {\n        this._addCondition(key, '$regex', regex)\n        if (!modifiers) {\n          modifiers = ''\n        }\n        // Javascript regex options support mig as inline options but store them\n        // as properties of the object. We support mi & should migrate them to\n        // modifiers\n        if (regex.ignoreCase) {\n          modifiers += 'i'\n        }\n        if (regex.multiline) {\n          modifiers += 'm'\n        }\n  \n        if (modifiers && modifiers.length) {\n          this._addCondition(key, '$options', modifiers)\n        }\n        return this\n      },\n  \n      /**\n       * Add a constraint that requires that a key's value matches a Parse.Query\n       * constraint.\n       * @param {String} key The key that the contains the object to match the\n       *                     query.\n       * @param {Parse.Query} query The query that should match.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      matchesQuery: function (key, query) {\n        var queryJSON = query.toJSON()\n        queryJSON.className = query.className\n        this._addCondition(key, '$inQuery', queryJSON)\n        return this\n      },\n  \n      /**\n        * Add a constraint that requires that a key's value not matches a\n        * Parse.Query constraint.\n        * @param {String} key The key that the contains the object to match the\n        *                     query.\n        * @param {Parse.Query} query The query that should not match.\n        * @return {Parse.Query} Returns the query, so you can chain this call.\n        */\n      doesNotMatchQuery: function (key, query) {\n        var queryJSON = query.toJSON()\n        queryJSON.className = query.className\n        this._addCondition(key, '$notInQuery', queryJSON)\n        return this\n      },\n  \n      /**\n       * Add a constraint that requires that a key's value matches a value in\n       * an object returned by a different Parse.Query.\n       * @param {String} key The key that contains the value that is being\n       *                     matched.\n       * @param {String} queryKey The key in the objects returned by the query to\n       *                          match against.\n       * @param {Parse.Query} query The query to run.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      matchesKeyInQuery: function (key, queryKey, query) {\n        var queryJSON = query.toJSON()\n        queryJSON.className = query.className\n        this._addCondition(key, '$select',\n          { key: queryKey, query: queryJSON })\n        return this\n      },\n  \n      /**\n       * Add a constraint that requires that a key's value not match a value in\n       * an object returned by a different Parse.Query.\n       * @param {String} key The key that contains the value that is being\n       *                     excluded.\n       * @param {String} queryKey The key in the objects returned by the query to\n       *                          match against.\n       * @param {Parse.Query} query The query to run.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      doesNotMatchKeyInQuery: function (key, queryKey, query) {\n        var queryJSON = query.toJSON()\n        queryJSON.className = query.className\n        this._addCondition(key, '$dontSelect',\n          { key: queryKey, query: queryJSON })\n        return this\n      },\n  \n      /**\n       * Add constraint that at least one of the passed in queries matches.\n       * @param {Array} queries\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      _orQuery: function (queries) {\n        var queryJSON = _.map(queries, function (q) {\n          return q.toJSON().where\n        })\n  \n        this._where.$or = queryJSON\n        return this\n      },\n  \n      /**\n       * Converts a string into a regex that matches it.\n       * Surrounding with \\Q .. \\E does this, we just need to escape \\E's in\n       * the text separately.\n       */\n      _quote: function (s) {\n        return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E'\n      },\n  \n      /**\n       * Add a constraint for finding string values that contain a provided\n       * string.  This may be slow for large datasets.\n       * @param {String} key The key that the string to match is stored in.\n       * @param {String} substring The substring that the value must contain.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      contains: function (key, value) {\n        this._addCondition(key, '$regex', this._quote(value))\n        return this\n      },\n  \n      /**\n       * Add a constraint for finding string values that start with a provided\n       * string.  This query will use the backend index, so it will be fast even\n       * for large datasets.\n       * @param {String} key The key that the string to match is stored in.\n       * @param {String} prefix The substring that the value must start with.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      startsWith: function (key, value) {\n        this._addCondition(key, '$regex', '^' + this._quote(value))\n        return this\n      },\n  \n      /**\n       * Add a constraint for finding string values that end with a provided\n       * string.  This will be slow for large datasets.\n       * @param {String} key The key that the string to match is stored in.\n       * @param {String} suffix The substring that the value must end with.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      endsWith: function (key, value) {\n        this._addCondition(key, '$regex', this._quote(value) + '$')\n        return this\n      },\n  \n      /**\n       * Sorts the results in ascending order by the given key.\n       *\n       * @param {(String|String[]|...String} key The key to order by, which is a\n       * string of comma separated values, or an Array of keys, or multiple keys.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      ascending: function () {\n        this._order = []\n        return this.addAscending.apply(this, arguments)\n      },\n  \n      /**\n       * Sorts the results in ascending order by the given key,\n       * but can also add secondary sort descriptors without overwriting _order.\n       *\n       * @param {(String|String[]|...String} key The key to order by, which is a\n       * string of comma separated values, or an Array of keys, or multiple keys.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      addAscending: function (key) {\n        var self = this\n        if (!this._order) {\n          this._order = []\n        }\n        Parse._arrayEach(arguments, function (key) {\n          if (Array.isArray(key)) {\n            key = key.join()\n          }\n          self._order = self._order.concat(key.replace(/\\s/g, '').split(','))\n        })\n        return this\n      },\n  \n      /**\n       * Sorts the results in descending order by the given key.\n       *\n       * @param {(String|String[]|...String} key The key to order by, which is a\n       * string of comma separated values, or an Array of keys, or multiple keys.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      descending: function (key) {\n        this._order = []\n        return this.addDescending.apply(this, arguments)\n      },\n  \n      /**\n       * Sorts the results in descending order by the given key,\n       * but can also add secondary sort descriptors without overwriting _order.\n       *\n       * @param {(String|String[]|...String} key The key to order by, which is a\n       * string of comma separated values, or an Array of keys, or multiple keys.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      addDescending: function (key) {\n        var self = this\n        if (!this._order) {\n          this._order = []\n        }\n        Parse._arrayEach(arguments, function (key) {\n          if (Array.isArray(key)) {\n            key = key.join()\n          }\n          self._order = self._order.concat(\n            _.map(key.replace(/\\s/g, '').split(','),\n              function (k) {\n                return '-' + k\n              }))\n        })\n        return this\n      },\n  \n      /**\n       * Add a proximity based constraint for finding objects with key point\n       * values near the point given.\n       * @param {String} key The key that the Parse.GeoPoint is stored in.\n       * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      near: function (key, point) {\n        if (!(point instanceof Parse.GeoPoint)) {\n          // Try to cast it to a GeoPoint, so that near(\"loc\", [20,30]) works.\n          point = new Parse.GeoPoint(point)\n        }\n        this._addCondition(key, '$nearSphere', point)\n        return this\n      },\n  \n      /**\n       * Add a proximity based constraint for finding objects with key point\n       * values near the point given and within the maximum distance given.\n       * @param {String} key The key that the Parse.GeoPoint is stored in.\n       * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n       * @param {Number} maxDistance Maximum distance (in radians) of results to\n       *   return.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      withinRadians: function (key, point, distance) {\n        this.near(key, point)\n        this._addCondition(key, '$maxDistance', distance)\n        return this\n      },\n  \n      /**\n       * Add a proximity based constraint for finding objects with key point\n       * values near the point given and within the maximum distance given.\n       * Radius of earth used is 3958.8 miles.\n       * @param {String} key The key that the Parse.GeoPoint is stored in.\n       * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n       * @param {Number} maxDistance Maximum distance (in miles) of results to\n       *     return.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      withinMiles: function (key, point, distance) {\n        return this.withinRadians(key, point, distance / 3958.8)\n      },\n  \n      /**\n       * Add a proximity based constraint for finding objects with key point\n       * values near the point given and within the maximum distance given.\n       * Radius of earth used is 6371.0 kilometers.\n       * @param {String} key The key that the Parse.GeoPoint is stored in.\n       * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n       * @param {Number} maxDistance Maximum distance (in kilometers) of results\n       *     to return.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      withinKilometers: function (key, point, distance) {\n        return this.withinRadians(key, point, distance / 6371.0)\n      },\n  \n      /**\n       * Add a constraint to the query that requires a particular key's\n       * coordinates be contained within a given rectangular geographic bounding\n       * box.\n       * @param {String} key The key to be constrained.\n       * @param {Parse.GeoPoint} southwest\n       *     The lower-left inclusive corner of the box.\n       * @param {Parse.GeoPoint} northeast\n       *     The upper-right inclusive corner of the box.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      withinGeoBox: function (key, southwest, northeast) {\n        if (!(southwest instanceof Parse.GeoPoint)) {\n          southwest = new Parse.GeoPoint(southwest)\n        }\n        if (!(northeast instanceof Parse.GeoPoint)) {\n          northeast = new Parse.GeoPoint(northeast)\n        }\n        this._addCondition(key, '$within', { '$box': [southwest, northeast] })\n        return this\n      },\n  \n      /**\n       * Include nested Parse.Objects for the provided key.  You can use dot\n       * notation to specify which fields in the included object are also fetched.\n       * @param {String} key The name of the key to include.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      include: function () {\n        var self = this\n        Parse._arrayEach(arguments, function (key) {\n          if (_.isArray(key)) {\n            self._include = self._include.concat(key)\n          } else {\n            self._include.push(key)\n          }\n        })\n        return this\n      },\n  \n      /**\n       * Restrict the fields of the returned Parse.Objects to include only the\n       * provided keys.  If this is called multiple times, then all of the keys\n       * specified in each of the calls will be included.\n       * @param {Array} keys The names of the keys to include.\n       * @return {Parse.Query} Returns the query, so you can chain this call.\n       */\n      select: function () {\n        var self = this\n        this._select = this._select || []\n        Parse._arrayEach(arguments, function (key) {\n          if (_.isArray(key)) {\n            self._select = self._select.concat(key)\n          } else {\n            self._select.push(key)\n          }\n        })\n        return this\n      },\n  \n      /**\n       * Iterates over each result of a query, calling a callback for each one. If\n       * the callback returns a promise, the iteration will not continue until\n       * that promise has been fulfilled. If the callback returns a rejected\n       * promise, then iteration will stop with that error. The items are\n       * processed in an unspecified order. The query may not have any sort order,\n       * and may not use limit or skip.\n       * @param {Function} callback Callback that will be called with each result\n       *     of the query.\n       * @param {Object} options An optional Backbone-like options object with\n       *     success and error callbacks that will be invoked once the iteration\n       *     has finished.\n       * @return {Parse.Promise} A promise that will be fulfilled once the\n       *     iteration has completed.\n       */\n      each: function (callback, options) {\n        options = options || {}\n  \n        if (this._order || this._skip || (this._limit >= 0)) {\n          var error =\n          'Cannot iterate on a query with sort, skip, or limit.'\n          return Parse.Promise.error(error)._thenRunCallbacks(options)\n        }\n  \n        var query = new Parse.Query(this.objectClass)\n        // We can override the batch size from the options.\n        // This is undocumented, but useful for testing.\n        query._limit = options.batchSize || 100\n        query._where = _.clone(this._where)\n        query._include = _.clone(this._include)\n        if (this._select) {\n          query._select = _.clone(this._select)\n        }\n  \n        query.ascending('objectId')\n  \n        var findOptions = {}\n        if (_.has(options, 'useMasterKey')) {\n          findOptions.useMasterKey = options.useMasterKey\n        }\n        if (_.has(options, 'sessionToken')) {\n          findOptions.sessionToken = options.sessionToken\n        }\n  \n        var finished = false\n        return Parse.Promise._continueWhile(function () {\n          return !finished\n        }, function () {\n          return query.find(findOptions).then(function (results) {\n            var callbacksDone = Parse.Promise.as()\n            Parse._.each(results, function (result) {\n              callbacksDone = callbacksDone.then(function () {\n                return callback(result)\n              })\n            })\n  \n            return callbacksDone.then(function () {\n              if (results.length >= query._limit) {\n                query.greaterThan('objectId', results[results.length - 1].id)\n              } else {\n                finished = true\n              }\n            })\n          })\n        })._thenRunCallbacks(options)\n      }\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n    var initialized = false\n    var requestedPermissions\n    var initOptions\n    var provider = {\n      authenticate: function (options) {\n        var self = this\n        FB.login(function (response) {\n          if (response.authResponse) {\n            if (options.success) {\n              options.success(self, {\n                id: response.authResponse.userID,\n                access_token: response.authResponse.accessToken,\n                expiration_date: new Date(response.authResponse.expiresIn * 1000 +\n                  (new Date()).getTime()).toJSON()\n              })\n            }\n          } else {\n            if (options.error) {\n              options.error(self, response)\n            }\n          }\n        }, {\n          scope: requestedPermissions\n        })\n      },\n      restoreAuthentication: function (authData) {\n        if (authData) {\n          var authResponse = {\n            userID: authData.id,\n            accessToken: authData.access_token,\n            expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\n              (new Date()).getTime()) / 1000\n          }\n          var newOptions = _.clone(initOptions)\n          newOptions.authResponse = authResponse\n  \n          // Suppress checks for login status from the browser.\n          newOptions.status = false\n  \n          // If the user doesn't match the one known by the FB SDK, log out.\n          // Most of the time, the users will match -- it's only in cases where\n          // the FB SDK knows of a different user than the one being restored\n          // from a Parse User that logged in with username/password.\n          var existingResponse = FB.getAuthResponse()\n          if (existingResponse &&\n            existingResponse.userID !== authResponse.userID) {\n            FB.logout()\n          }\n  \n          FB.init(newOptions)\n        }\n        return true\n      },\n      getAuthType: function () {\n        return 'facebook'\n      },\n      deauthenticate: function () {\n        this.restoreAuthentication(null)\n      }\n    }\n  \n    /**\n     * Provides a set of utilities for using Parse with Facebook.\n     * @namespace\n     * Provides a set of utilities for using Parse with Facebook.\n     */\n    Parse.FacebookUtils = {\n      /**\n       * Initializes Parse Facebook integration.  Call this function after you\n       * have loaded the Facebook Javascript SDK with the same parameters\n       * as you would pass to<code>\n       * <a href=\n       * \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n       * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\n       * with these arguments.\n       *\n       * @param {Object} options Facebook options argument as described here:\n       *   <a href=\n       *   \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n       *   FB.init()</a>. The status flag will be coerced to 'false' because it\n       *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\n       *   explicitly if this behavior is required by your application.\n       */\n      init: function (options) {\n        if (typeof (FB) === 'undefined') {\n          throw new Error('The Facebook JavaScript SDK must be loaded before calling init.')\n        }\n        initOptions = _.clone(options) || {}\n        if (initOptions.status && typeof (console) !== 'undefined') {\n          var warn = console.warn || console.log || function () {}\n          warn.call(console, \"The 'status' flag passed into\" +\n            ' FB.init, when set to true, can interfere with Parse Facebook' +\n            ' integration, so it has been suppressed. Please call' +\n            ' FB.getLoginStatus() explicitly if you require this behavior.')\n        }\n        initOptions.status = false\n        FB.init(initOptions)\n        Parse.User._registerAuthenticationProvider(provider)\n        initialized = true\n      },\n  \n      /**\n       * Gets whether the user has their account linked to Facebook.\n       *\n       * @param {Parse.User} user User to check for a facebook link.\n       *     The user must be logged in on this device.\n       * @return {Boolean} <code>true</code> if the user has their account\n       *     linked to Facebook.\n       */\n      isLinked: function (user) {\n        return user._isLinked('facebook')\n      },\n  \n      /**\n       * Logs in a user using Facebook. This method delegates to the Facebook\n       * SDK to authenticate the user, and then automatically logs in (or\n       * creates, in the case where it is a new user) a Parse.User.\n       *\n       * @param {String, Object} permissions The permissions required for Facebook\n       *    log in.  This is a comma-separated string of permissions.\n       *    Alternatively, supply a Facebook authData object as described in our\n       *    REST API docs if you want to handle getting facebook auth tokens\n       *    yourself.\n       * @param {Object} options Standard options object with success and error\n       *    callbacks.\n       */\n      logIn: function (permissions, options) {\n        if (!permissions || _.isString(permissions)) {\n          if (!initialized) {\n            throw new Error('You must initialize FacebookUtils before calling logIn.')\n          }\n          requestedPermissions = permissions\n          return Parse.User._logInWith('facebook', options)\n        } else {\n          var newOptions = _.clone(options) || {}\n          newOptions.authData = permissions\n          return Parse.User._logInWith('facebook', newOptions)\n        }\n      },\n  \n      /**\n       * Links Facebook to an existing PFUser. This method delegates to the\n       * Facebook SDK to authenticate the user, and then automatically links\n       * the account to the Parse.User.\n       *\n       * @param {Parse.User} user User to link to Facebook. This must be the\n       *     current user.\n       * @param {String, Object} permissions The permissions required for Facebook\n       *    log in.  This is a comma-separated string of permissions.\n       *    Alternatively, supply a Facebook authData object as described in our\n       *    REST API docs if you want to handle getting facebook auth tokens\n       *    yourself.\n       * @param {Object} options Standard options object with success and error\n       *    callbacks.\n       */\n      link: function (user, permissions, options) {\n        if (!permissions || _.isString(permissions)) {\n          if (!initialized) {\n            throw new Error('You must initialize FacebookUtils before calling link.')\n          }\n          requestedPermissions = permissions\n          return user._linkWith('facebook', options)\n        } else {\n          var newOptions = _.clone(options) || {}\n          newOptions.authData = permissions\n          return user._linkWith('facebook', newOptions)\n        }\n      },\n  \n      /**\n       * Unlinks the Parse.User from a Facebook account.\n       *\n       * @param {Parse.User} user User to unlink from Facebook. This must be the\n       *     current user.\n       * @param {Object} options Standard options object with success and error\n       *    callbacks.\n       */\n      unlink: function (user, options) {\n        if (!initialized) {\n          throw new Error('You must initialize FacebookUtils before calling unlink.')\n        }\n        return user._unlinkFrom('facebook', options)\n      }\n    }\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * History serves as a global router (per frame) to handle hashchange\n     * events or pushState, match the appropriate route, and trigger\n     * callbacks. You shouldn't ever have to create one of these yourself\n     * â€” you should use the reference to <code>Parse.history</code>\n     * that will be created for you automatically if you make use of\n     * Routers with routes.\n     * @class\n     *\n     * <p>A fork of Backbone.History, provided for your convenience.  If you\n     * use this class, you must also include jQuery, or another library\n     * that provides a jQuery-compatible $ function.  For more information,\n     * see the <a href=\"http://documentcloud.github.com/backbone/#History\">\n     * Backbone documentation</a>.</p>\n     * <p><strong><em>Available in the client SDK only.</em></strong></p>\n     */\n    Parse.History = function () {\n      this.handlers = []\n      _.bindAll(this, 'checkUrl')\n    }\n  \n    // Cached regex for cleaning leading hashes and slashes .\n    var routeStripper = /^[#\\/]/\n  \n    // Cached regex for detecting MSIE.\n    var isExplorer = /msie [\\w.]+/\n  \n    // Has the history handling already been started?\n    Parse.History.started = false\n  \n    // Set up all inheritable **Parse.History** properties and methods.\n    _.extend(Parse.History.prototype, Parse.Events, {\n  \n      // The default interval to poll for hash changes, if necessary, is\n      // twenty times a second.\n      interval: 50,\n  \n      // Gets the true hash value. Cannot use location.hash directly due to bug\n      // in Firefox where location.hash will always be decoded.\n      getHash: function (windowOverride) {\n        var loc = windowOverride ? windowOverride.location : window.location\n        var match = loc.href.match(/#(.*)$/)\n        return match ? match[1] : ''\n      },\n  \n      // Get the cross-browser normalized URL fragment, either from the URL,\n      // the hash, or the override.\n      getFragment: function (fragment, forcePushState) {\n        if (Parse._isNullOrUndefined(fragment)) {\n          if (this._hasPushState || forcePushState) {\n            fragment = window.location.pathname\n            var search = window.location.search\n            if (search) {\n              fragment += search\n            }\n          } else {\n            fragment = this.getHash()\n          }\n        }\n        if (!fragment.indexOf(this.options.root)) {\n          fragment = fragment.substr(this.options.root.length)\n        }\n        return fragment.replace(routeStripper, '')\n      },\n  \n      /**\n       * Start the hash change handling, returning `true` if the current\n       * URL matches an existing route, and `false` otherwise.\n       */\n      start: function (options) {\n        if (Parse.History.started) {\n          throw new Error('Parse.history has already been started')\n        }\n        Parse.History.started = true\n  \n        // Figure out the initial configuration. Do we need an iframe?\n        // Is pushState desired ... is it available?\n        this.options = _.extend({}, {root: '/'}, this.options, options)\n        this._wantsHashChange = this.options.hashChange !== false\n        this._wantsPushState = !!this.options.pushState\n        this._hasPushState = !!(this.options.pushState &&\n          window.history &&\n          window.history.pushState)\n        var fragment = this.getFragment()\n        var docMode = document.documentMode\n        var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\n          (!docMode || docMode <= 7))\n  \n        if (oldIE) {\n          this.iframe = Parse.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />')\n            .hide().appendTo('body')[0].contentWindow\n          this.navigate(fragment)\n        }\n  \n        // Depending on whether we're using pushState or hashes, and whether\n        // 'onhashchange' is supported, determine how we check the URL state.\n        if (this._hasPushState) {\n          Parse.$(window).bind('popstate', this.checkUrl)\n        } else if (this._wantsHashChange &&\n          ('onhashchange' in window) &&\n          !oldIE) {\n          Parse.$(window).bind('hashchange', this.checkUrl)\n        } else if (this._wantsHashChange) {\n          this._checkUrlInterval = window.setInterval(this.checkUrl,\n            this.interval)\n        }\n  \n        // Determine if we need to change the base url, for a pushState link\n        // opened by a non-pushState browser.\n        this.fragment = fragment\n        var loc = window.location\n        var atRoot = loc.pathname === this.options.root\n  \n        // If we've started off with a route from a `pushState`-enabled browser,\n        // but we're currently in a browser that doesn't support it...\n        if (this._wantsHashChange &&\n          this._wantsPushState &&\n          !this._hasPushState &&\n          !atRoot) {\n          this.fragment = this.getFragment(null, true)\n          window.location.replace(this.options.root + '#' + this.fragment)\n          // Return immediately as browser will do redirect to new url\n          return true\n  \n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._wantsPushState &&\n          this._hasPushState &&\n          atRoot &&\n          loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '')\n          window.history.replaceState({}, document.title,\n            loc.protocol + '//' + loc.host + this.options.root + this.fragment)\n        }\n  \n        if (!this.options.silent) {\n          return this.loadUrl()\n        }\n      },\n  \n      // Disable Parse.history, perhaps temporarily. Not useful in a real app,\n      // but possibly useful for unit testing Routers.\n      stop: function () {\n        Parse.$(window).unbind('popstate', this.checkUrl)\n          .unbind('hashchange', this.checkUrl)\n        window.clearInterval(this._checkUrlInterval)\n        Parse.History.started = false\n      },\n  \n      // Add a route to be tested when the fragment changes. Routes added later\n      // may override previous routes.\n      route: function (route, callback) {\n        this.handlers.unshift({route: route, callback: callback})\n      },\n  \n      // Checks the current URL to see if it has changed, and if it has,\n      // calls `loadUrl`, normalizing across the hidden iframe.\n      checkUrl: function (e) {\n        var current = this.getFragment()\n        if (current === this.fragment && this.iframe) {\n          current = this.getFragment(this.getHash(this.iframe))\n        }\n        if (current === this.fragment) {\n          return false\n        }\n        if (this.iframe) {\n          this.navigate(current)\n        }\n        if (!this.loadUrl()) {\n          this.loadUrl(this.getHash())\n        }\n      },\n  \n      // Attempt to load the current URL fragment. If a route succeeds with a\n      // match, returns `true`. If no defined routes matches the fragment,\n      // returns `false`.\n      loadUrl: function (fragmentOverride) {\n        var fragment = this.fragment = this.getFragment(fragmentOverride)\n        var matched = _.any(this.handlers, function (handler) {\n          if (handler.route.test(fragment)) {\n            handler.callback(fragment)\n            return true\n          }\n        })\n        return matched\n      },\n  \n      // Save a fragment into the hash history, or replace the URL state if the\n      // 'replace' option is passed. You are responsible for properly URL-encoding\n      // the fragment in advance.\n      //\n      // The options object can contain `trigger: true` if you wish to have the\n      // route callback be fired (not usually desirable), or `replace: true`, if\n      // you wish to modify the current URL without adding an entry to the\n      // history.\n      navigate: function (fragment, options) {\n        if (!Parse.History.started) {\n          return false\n        }\n        if (!options || options === true) {\n          options = {trigger: options}\n        }\n        var frag = (fragment || '').replace(routeStripper, '')\n        if (this.fragment === frag) {\n          return\n        }\n  \n        // If pushState is available, we use it to set the fragment as a real URL.\n        if (this._hasPushState) {\n          if (frag.indexOf(this.options.root) !== 0) {\n            frag = this.options.root + frag\n          }\n          this.fragment = frag\n          var replaceOrPush = options.replace ? 'replaceState' : 'pushState'\n          window.history[replaceOrPush]({}, document.title, frag)\n  \n        // If hash changes haven't been explicitly disabled, update the hash\n        // fragment to store history.\n        } else if (this._wantsHashChange) {\n          this.fragment = frag\n          this._updateHash(window.location, frag, options.replace)\n          if (this.iframe &&\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\n            // Opening and closing the iframe tricks IE7 and earlier\n            // to push a history entry on hash-tag change.\n            // When replace is true, we don't want this.\n            if (!options.replace) {\n              this.iframe.document.open().close()\n            }\n            this._updateHash(this.iframe.location, frag, options.replace)\n          }\n  \n        // If you've told us that you explicitly don't want fallback hashchange-\n        // based history, then `navigate` becomes a page refresh.\n        } else {\n          window.location.assign(this.options.root + fragment)\n        }\n        if (options.trigger) {\n          this.loadUrl(fragment)\n        }\n      },\n  \n      // Update the hash location, either replacing the current entry, or adding\n      // a new one to the browser history.\n      _updateHash: function (location, fragment, replace) {\n        if (replace) {\n          var s = location.toString().replace(/(javascript:|#).*$/, '')\n          location.replace(s + '#' + fragment)\n        } else {\n          location.hash = fragment\n        }\n      }\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * Routers map faux-URLs to actions, and fire events when routes are\n     * matched. Creating a new one sets its `routes` hash, if not set statically.\n     * @class\n     *\n     * <p>A fork of Backbone.Router, provided for your convenience.\n     * For more information, see the\n     * <a href=\"http://documentcloud.github.com/backbone/#Router\">Backbone\n     * documentation</a>.</p>\n     * <p><strong><em>Available in the client SDK only.</em></strong></p>\n     */\n    Parse.Router = function (options) {\n      options = options || {}\n      if (options.routes) {\n        this.routes = options.routes\n      }\n      this._bindRoutes()\n      this.initialize.apply(this, arguments)\n    }\n  \n    // Cached regular expressions for matching named param parts and splatted\n    // parts of route strings.\n    var namedParam = /:\\w+/g\n    var splatParam = /\\*\\w+/g\n    var escapeRegExp = /[\\-\\[\\]{}()+?.,\\\\\\^\\$\\|#\\s]/g\n  \n    // Set up all inheritable **Parse.Router** properties and methods.\n    _.extend(Parse.Router.prototype, Parse.Events, {\n  \n      /**\n       * Initialize is an empty function by default. Override it with your own\n       * initialization logic.\n       */\n      initialize: function () {},\n  \n      /**\n       * Manually bind a single named route to a callback. For example:\n       *\n       * <pre>this.route('search/:query/p:num', 'search', function(query, num) {\n       *       ...\n       *     });</pre>\n       */\n      route: function (route, name, callback) {\n        Parse.history = Parse.history || new Parse.History()\n        if (!_.isRegExp(route)) {\n          route = this._routeToRegExp(route)\n        }\n        if (!callback) {\n          callback = this[name]\n        }\n        Parse.history.route(route, _.bind(function (fragment) {\n          var args = this._extractParameters(route, fragment)\n          if (callback) {\n            callback.apply(this, args)\n          }\n          this.trigger.apply(this, ['route:' + name].concat(args))\n          Parse.history.trigger('route', this, name, args)\n        }, this))\n        return this\n      },\n  \n      /**\n       * Whenever you reach a point in your application that you'd\n       * like to save as a URL, call navigate in order to update the\n       * URL. If you wish to also call the route function, set the\n       * trigger option to true. To update the URL without creating\n       * an entry in the browser's history, set the replace option\n       * to true.\n       */\n      navigate: function (fragment, options) {\n        Parse.history.navigate(fragment, options)\n      },\n  \n      // Bind all defined routes to `Parse.history`. We have to reverse the\n      // order of the routes here to support behavior where the most general\n      // routes can be defined at the bottom of the route map.\n      _bindRoutes: function () {\n        if (!this.routes) {\n          return\n        }\n        var routes = []\n        for (var route in this.routes) {\n          if (this.routes.hasOwnProperty(route)) {\n            routes.unshift([route, this.routes[route]])\n          }\n        }\n        for (var i = 0, l = routes.length; i < l; i++) {\n          this.route(routes[i][0], routes[i][1], this[routes[i][1]])\n        }\n      },\n  \n      // Convert a route string into a regular expression, suitable for matching\n      // against the current location hash.\n      _routeToRegExp: function (route) {\n        route = route.replace(escapeRegExp, '\\\\$&')\n          .replace(namedParam, '([^/]+)')\n          .replace(splatParam, '(.*?)')\n        return new RegExp('^' + route + '$')\n      },\n  \n      // Given a route, and a URL fragment that it matches, return the array of\n      // extracted parameters.\n      _extractParameters: function (route, fragment) {\n        return route.exec(fragment).slice(1)\n      }\n    })\n  \n    /**\n     * @function\n     * @param {Object} instanceProps Instance properties for the router.\n     * @param {Object} classProps Class properies for the router.\n     * @return {Class} A new subclass of <code>Parse.Router</code>.\n     */\n    Parse.Router.extend = Parse._extend\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n    var _ = Parse._\n  \n    /**\n     * @namespace Contains functions for calling and declaring\n     * <a href=\"/docs/cloud_code_guide#functions\">cloud functions</a>.\n     * <p><strong><em>\n     *   Some functions are only available from Cloud Code.\n     * </em></strong></p>\n     */\n    Parse.Cloud = Parse.Cloud || {}\n  \n    _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\n      /**\n       * Makes a call to a cloud function.\n       * @param {String} name The function name.\n       * @param {Object} data The parameters to send to the cloud function.\n       * @param {Object} options A Backbone-style options object\n       * options.success, if set, should be a function to handle a successful\n       * call to a cloud function.  options.error should be a function that\n       * handles an error running the cloud function.  Both functions are\n       * optional.  Both functions take a single argument.\n       * @return {Parse.Promise} A promise that will be resolved with the result\n       * of the function.\n       */\n      run: function (name, data, options) {\n        options = options || {}\n  \n        var request = Parse._request({\n          route: 'functions',\n          className: name,\n          method: 'POST',\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken,\n          data: Parse._encode(data, null, true)\n        })\n  \n        return request.then(function (resp) {\n          return Parse._decode(null, resp).result\n        })._thenRunCallbacks(options)\n      }\n    })\n  }(this))\n  \n  ;(function (root) {\n    root.Parse = root.Parse || {}\n    var Parse = root.Parse\n  \n    Parse.Installation = Parse.Object.extend('_Installation')\n  \n    /**\n     * Contains functions to deal with Push in Parse\n     * @name Parse.Push\n     * @namespace\n     */\n    Parse.Push = Parse.Push || {}\n  \n    /**\n     * Sends a push notification.\n     * @param {Object} data -  The data of the push notification.  Valid fields\n     * are:\n     *   <ol>\n     *     <li>channels - An Array of channels to push to.</li>\n     *     <li>push_time - A Date object for when to send the push.</li>\n     *     <li>expiration_time -  A Date object for when to expire\n     *         the push.</li>\n     *     <li>expiration_interval - The seconds from now to expire the push.</li>\n     *     <li>where - A Parse.Query over Parse.Installation that is used to match\n     *         a set of installations to push to.</li>\n     *     <li>data - The data to send as part of the push</li>\n     *   <ol>\n     * @param {Object} options An object that has an optional success function,\n     * that takes no arguments and will be called on a successful push, and\n     * an error function that takes a Parse.Error and will be called if the push\n     * failed.\n     * @return {Parse.Promise} A promise that is fulfilled when the push request\n     *     completes.\n     */\n    Parse.Push.send = function (data, options) {\n      options = options || {}\n  \n      if (data.where) {\n        data.where = data.where.toJSON().where\n      }\n  \n      if (data.push_time) {\n        data.push_time = data.push_time.toJSON()\n      }\n  \n      if (data.expiration_time) {\n        data.expiration_time = data.expiration_time.toJSON()\n      }\n  \n      if (data.expiration_time && data.expiration_interval) {\n        throw new Error(\"Both expiration_time and expiration_interval can't be set\")\n      }\n  \n      var request = Parse._request({\n        route: 'push',\n        method: 'POST',\n        data: data,\n        useMasterKey: options.useMasterKey\n      })\n      return request._thenRunCallbacks(options)\n    }\n  }(this))\n  \n\n  this._ = this.Parse._\n}).call(moduleExport)\n\nif (typeof define === 'function' && define.amd) {\n  define(moduleExport)\n} else if (typeof module === 'object' && module.exports) {\n  module.exports = moduleExport\n}\n"],"sourceRoot":"/source/"}